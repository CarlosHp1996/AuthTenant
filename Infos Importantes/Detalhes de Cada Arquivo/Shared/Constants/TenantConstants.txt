=================================
DOCUMENTAÇÃO TÉCNICA - TenantConstants.cs
=================================

ARQUIVO: AuthTenant.Shared/Constants/TenantConstants.cs
CATEGORIA: Constants and Configuration (Shared)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
TenantConstants é uma classe estática que centraliza todas as constantes relacionadas
ao sistema de multi-tenancy. Fornece identificadores, configurações, validações,
mensagens de erro e métodos utilitários para gerenciamento de tenants em toda a aplicação.

RESPONSABILIDADES:
• Centralizar todas as constantes de multi-tenancy
• Fornecer identificadores para headers, claims e context keys
• Definir padrões de validação para IDs e nomes de tenant
• Estabelecer templates de cache keys
• Fornecer configurações padrão do sistema
• Definir mensagens de erro padronizadas
• Implementar métodos utilitários de validação
• Gerenciar estratégias de resolução de tenant

ARQUITETURA:
• Constants Pattern
• Static Utility Class Pattern
• Configuration Management Pattern
• Validation Strategy Pattern
• Cache Key Management Pattern
• Error Message Centralization
• Multi-Strategy Resolution Support

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. IDENTIFICAÇÃO DE TENANT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONSTANTES DE IDENTIFICAÇÃO:
• DefaultTenantId: "default" - Tenant padrão quando nenhum é identificado
• TenantIdHeaderName: "X-Tenant-Id" - Header HTTP para tenant ID
• TenantIdClaimType: "tenant_id" - Claim JWT para tenant ID
• TenantIdContextKey: "TenantId" - Chave no HttpContext.Items
• TenantNameClaimType: "tenant_name" - Claim opcional para nome

ESTRATÉGIAS DE RESOLUÇÃO:
• Header HTTP: Mais comum para APIs REST
• JWT Claims: Mais seguro para aplicações autenticadas
• Context Items: Para uso interno na pipeline
• Subdomain: Para aplicações web multi-tenant
• Path/QueryString: Para casos específicos

USAGE PATTERNS:
```csharp
// Resolver via header
var tenantId = httpContext.Request.Headers[TenantConstants.TenantIdHeaderName];

// Resolver via claim
var tenantClaim = user.FindFirst(TenantConstants.TenantIdClaimType);

// Armazenar em context
httpContext.Items[TenantConstants.TenantIdContextKey] = tenantId;
```

FALLBACK STRATEGY:
• DefaultTenantId usado quando resolução falha
• Permite operação degradada da aplicação
• Facilita desenvolvimento e testes
• Compatibility com single-tenant scenarios

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. VALIDAÇÃO E CONSTRAINTS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TENANT ID VALIDATION:
• MinTenantIdLength: 1 - Comprimento mínimo
• MaxTenantIdLength: 50 - Comprimento máximo
• TenantIdValidationPattern: @"^[a-zA-Z0-9\-_]+$" - Regex pattern
• Permite apenas alfanuméricos, hífen e underscore
• Case-sensitive para uniqueness

TENANT NAME VALIDATION:
• MinTenantNameLength: 1 - Comprimento mínimo
• MaxTenantNameLength: 100 - Comprimento máximo  
• TenantNameValidationPattern: @"^[a-zA-Z0-9\s\-_]+$" - Regex pattern
• Permite espaços além de alfanuméricos
• Case-insensitive para user experience

VALIDATION METHODS:
• IsValidTenantId(): Valida formato de ID
• IsValidTenantName(): Valida formato de nome
• IsDefaultTenant(): Verifica se é tenant padrão
• NormalizeTenantId(): Normaliza para lowercase

BUSINESS RULES:
• Tenant ID deve ser único no sistema
• Tenant Name deve ser único (case-insensitive)
• IDs são case-sensitive para segurança
• Names são case-insensitive para UX
• Validation antes de persistence

EXAMPLE USAGE:
```csharp
public async Task<Tenant> CreateTenantAsync(string id, string name)
{
    if (!TenantConstants.IsValidTenantId(id))
        throw new ValidationException("Invalid tenant ID format");
        
    if (!TenantConstants.IsValidTenantName(name))
        throw new ValidationException("Invalid tenant name format");
        
    // Proceed with creation...
}
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. CACHE MANAGEMENT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CACHE KEY TEMPLATES:
• CacheKeyPrefix: "tenant" - Prefixo para todas as chaves
• TenantByIdCacheKeyTemplate: "tenant_id_{0}" - Template por ID
• TenantByNameCacheKeyTemplate: "tenant_name_{0}" - Template por nome
• ActiveTenantsCacheKey: "active_tenants" - Lista de tenants ativos
• TenantStatisticsCacheKey: "tenant_statistics" - Estatísticas

CACHE KEY GENERATION:
• GetTenantByIdCacheKey(): Gera chave por ID com normalização
• GetTenantByNameCacheKey(): Gera chave por nome com normalização
• Normalização automática para lowercase
• Consistent key format em toda aplicação

CACHE STRATEGIES:
• Por ID: Cache mais frequente, TTL longo
• Por Nome: Para lookups de user-facing features
• Lista Ativa: Para dropdowns e seletores
• Estatísticas: Para dashboards e relatórios
• Invalidation coordenada entre chaves relacionadas

USAGE EXAMPLE:
```csharp
public async Task<Tenant?> GetTenantAsync(string tenantId)
{
    var cacheKey = TenantConstants.GetTenantByIdCacheKey(tenantId);
    
    if (_cache.TryGetValue(cacheKey, out Tenant tenant))
        return tenant;
        
    tenant = await _repository.GetByIdAsync(tenantId);
    if (tenant != null)
    {
        _cache.Set(cacheKey, tenant, TimeSpan.FromMinutes(30));
    }
    
    return tenant;
}
```

CACHE INVALIDATION:
• Create: Invalidar listas e estatísticas
• Update: Invalidar ID, nome e listas
• Delete: Invalidar todas as chaves relacionadas
• Bulk Operations: Invalidar caches em lote
• Coordinated invalidation strategy

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. CONFIGURAÇÃO E SETTINGS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONFIGURATION KEYS:
• MultiTenancyEnabledConfigKey: "MultiTenancy:Enabled" - Enable/disable
• TenantResolutionStrategyConfigKey: "MultiTenancy:ResolutionStrategy" - Strategy
• TenantCacheDurationConfigKey: "MultiTenancy:CacheDurationMinutes" - Cache TTL
• TenantLoggingEnabledConfigKey: "MultiTenancy:LoggingEnabled" - Logging control

RESOLUTION STRATEGIES:
• HeaderResolutionStrategy: "Header" - Via HTTP header
• ClaimResolutionStrategy: "Claim" - Via JWT claim
• SubdomainResolutionStrategy: "Subdomain" - Via subdomain
• PathResolutionStrategy: "Path" - Via URL path
• QueryStringResolutionStrategy: "QueryString" - Via query parameter

APPSETTINGS EXAMPLE:
```json
{
  "MultiTenancy": {
    "Enabled": true,
    "ResolutionStrategy": "Header",
    "CacheDurationMinutes": 30,
    "LoggingEnabled": true
  }
}
```

CONFIGURATION USAGE:
```csharp
public class TenantService
{
    private readonly bool _multiTenancyEnabled;
    private readonly string _resolutionStrategy;
    
    public TenantService(IConfiguration configuration)
    {
        _multiTenancyEnabled = configuration.GetValue<bool>(
            TenantConstants.MultiTenancyEnabledConfigKey, true);
            
        _resolutionStrategy = configuration.GetValue<string>(
            TenantConstants.TenantResolutionStrategyConfigKey, 
            TenantConstants.HeaderResolutionStrategy);
    }
}
```

ENVIRONMENT SPECIFIC:
• Development: Logging habilitado, cache menor
• Staging: Configuração próxima à produção
• Production: Performance otimizada, logging mínimo
• Testing: Multi-tenancy desabilitado ou simplificado

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. MENSAGENS DE ERRO PADRONIZADAS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ERROR MESSAGE CONSTANTS:
• TenantNotFoundErrorMessage: "Tenant '{0}' was not found."
• TenantInactiveErrorMessage: "Tenant '{0}' is currently inactive."
• InvalidTenantIdErrorMessage: "Tenant ID '{0}' is invalid. Must match pattern: {1}"
• InvalidTenantNameErrorMessage: "Tenant name '{0}' is invalid. Must match pattern: {1}"
• TenantIdExistsErrorMessage: "Tenant with ID '{0}' already exists."
• TenantNameExistsErrorMessage: "Tenant with name '{0}' already exists."

ERROR MESSAGE USAGE:
```csharp
public class TenantValidationService
{
    public void ValidateTenantId(string tenantId)
    {
        if (!TenantConstants.IsValidTenantId(tenantId))
        {
            throw new ValidationException(string.Format(
                TenantConstants.InvalidTenantIdErrorMessage,
                tenantId,
                TenantConstants.TenantIdValidationPattern));
        }
    }
}
```

LOCALIZATION SUPPORT:
• Constants fornecem templates base
• Resource files podem override messages
• Consistent parameter placeholders
• Culture-specific formatting
• Fallback para constants se resource não disponível

EXCEPTION INTEGRATION:
• TenantNotFoundException com message template
• TenantInactiveException com context
• ValidationException com detailed info
• Business exceptions com user-friendly messages
• Technical exceptions com debug info

USER EXPERIENCE:
• Clear, actionable error messages
• Consistent formatting across application
• Professional tone e language
• Help text quando apropriado
• Suggest corrections where possible

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. HTTP HEADERS E RESPONSE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

RESPONSE HEADERS:
• TenantInfoResponseHeader: "X-Tenant-Info" - Informações do tenant
• TenantResolvedHeader: "X-Tenant-Resolved" - Se tenant foi resolvido
• TenantResolutionMethodHeader: "X-Tenant-Resolution-Method" - Método usado

HEADER USAGE:
```csharp
public class TenantMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var tenantId = ResolveTenant(context);
        
        if (!string.IsNullOrEmpty(tenantId))
        {
            context.Response.Headers[TenantConstants.TenantResolvedHeader] = "true";
            context.Response.Headers[TenantConstants.TenantInfoResponseHeader] = tenantId;
            context.Response.Headers[TenantConstants.TenantResolutionMethodHeader] = "Header";
        }
        
        await _next(context);
    }
}
```

DEBUGGING SUPPORT:
• Headers ajudam troubleshooting
• Client pode verificar tenant resolution
• API testing facilitated
• Integration debugging simplified
• Monitoring e analytics enhanced

CLIENT INTEGRATION:
• Frontend pode ler tenant info
• API clients podem validar tenant
• Error handling mais específico
• Cache invalidation coordenada
• User experience improvements

SECURITY CONSIDERATIONS:
• Headers podem expor tenant information
• Consider security implications
• Configurável via settings
• Production vs development behavior
• Sanitize sensitive information

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. ROLES E PERMISSIONS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ROLE CONSTANTS:
• TenantAdminRole: "TenantAdmin" - Administrador do tenant
• TenantUserRole: "TenantUser" - Usuário normal do tenant
• SystemAdminRole: "SystemAdmin" - Administrador do sistema

PERMISSION CONSTANTS:
• CreateTenantPermission: "tenant:create" - Criar tenants
• ReadTenantPermission: "tenant:read" - Ler dados de tenant
• UpdateTenantPermission: "tenant:update" - Atualizar tenant
• DeleteTenantPermission: "tenant:delete" - Deletar tenant

AUTHORIZATION USAGE:
```csharp
[Authorize(Roles = TenantConstants.TenantAdminRole)]
public class TenantManagementController : ControllerBase
{
    [HttpPost]
    [RequiresPermission(TenantConstants.CreateTenantPermission)]
    public async Task<IActionResult> CreateTenant(CreateTenantRequest request)
    {
        // Implementation...
    }
}
```

ROLE HIERARCHY:
• SystemAdmin: Acesso a todos os tenants
• TenantAdmin: Acesso completo ao seu tenant
• TenantUser: Acesso limitado ao seu tenant
• Roles podem ser compostas com permissions
• Fine-grained access control

PERMISSION-BASED AUTHORIZATION:
• Granular permissions para actions específicas
• Composition de permissions em roles
• Dynamic permission assignment
• Resource-based authorization
• Tenant-scoped permissions

CLAIMS INTEGRATION:
• Roles e permissions em JWT claims
• Tenant-specific role assignment
• Dynamic role resolution
• Cache de authorization decisions
• Performance-optimized checks

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. DATABASE INTEGRATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DATABASE CONSTANTS:
• TenantsTableName: "Tenants" - Nome da tabela
• TenantIdColumnName: "TenantId" - Nome da coluna
• TenantIdIndexName: "IX_TenantId" - Nome do índice

ENTITY FRAMEWORK INTEGRATION:
```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<Tenant> Tenants { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Tenant>(entity =>
        {
            entity.ToTable(TenantConstants.TenantsTableName);
            entity.HasIndex(t => t.Id).HasDatabaseName(TenantConstants.TenantIdIndexName);
        });
        
        // Configure tenant filters for all entities
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            if (typeof(ITenantEntity).IsAssignableFrom(entityType.ClrType))
            {
                modelBuilder.Entity(entityType.ClrType)
                    .HasIndex(TenantConstants.TenantIdColumnName)
                    .HasDatabaseName($"IX_{entityType.ClrType.Name}_{TenantConstants.TenantIdColumnName}");
            }
        }
    }
}
```

QUERY FILTERS:
• Global query filters por tenant
• Automatic tenant isolation
• Index optimization
• Performance considerations
• Security enforcement

MIGRATION SUPPORT:
• Constants em migrations para consistency
• Table e column naming standards
• Index creation patterns
• Tenant data seeding
• Schema evolution strategy

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. UTILITY METHODS E BEST PRACTICES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

UTILITY METHODS:
• GetTenantByIdCacheKey(): Cache key generation
• GetTenantByNameCacheKey(): Cache key por nome
• IsValidTenantId(): ID validation
• IsValidTenantName(): Name validation
• IsDefaultTenant(): Default tenant check
• NormalizeTenantId(): ID normalization

VALIDATION BEST PRACTICES:
```csharp
public class TenantService
{
    public async Task<Result<Tenant>> CreateTenantAsync(string id, string name)
    {
        // Normalize input
        id = TenantConstants.NormalizeTenantId(id);
        name = name?.Trim();
        
        // Validate format
        if (!TenantConstants.IsValidTenantId(id))
            return Result.Failure("Invalid tenant ID format");
            
        if (!TenantConstants.IsValidTenantName(name))
            return Result.Failure("Invalid tenant name format");
            
        // Check uniqueness
        if (await _repository.ExistsAsync(id))
            return Result.Failure("Tenant ID already exists");
            
        // Create tenant
        var tenant = new Tenant { Id = id, Name = name };
        return Result.Success(await _repository.CreateAsync(tenant));
    }
}
```

CACHE KEY MANAGEMENT:
```csharp
public class TenantCacheService
{
    public async Task InvalidateTenantCacheAsync(string tenantId, string tenantName)
    {
        var idKey = TenantConstants.GetTenantByIdCacheKey(tenantId);
        var nameKey = TenantConstants.GetTenantByNameCacheKey(tenantName);
        
        _cache.Remove(idKey);
        _cache.Remove(nameKey);
        _cache.Remove(TenantConstants.ActiveTenantsCacheKey);
        _cache.Remove(TenantConstants.TenantStatisticsCacheKey);
    }
}
```

RESOLUTION STRATEGY:
```csharp
public class TenantResolver
{
    public string? ResolveTenant(HttpContext context)
    {
        // Try header first
        var tenantId = context.Request.Headers[TenantConstants.TenantIdHeaderName].FirstOrDefault();
        if (TenantConstants.IsValidTenantId(tenantId))
            return TenantConstants.NormalizeTenantId(tenantId);
            
        // Try claim second
        var claim = context.User?.FindFirst(TenantConstants.TenantIdClaimType);
        if (claim != null && TenantConstants.IsValidTenantId(claim.Value))
            return TenantConstants.NormalizeTenantId(claim.Value);
            
        // Fallback to default
        return TenantConstants.DefaultTenantId;
    }
}
```

CONFIGURATION INTEGRATION:
```csharp
public class TenantConfiguration
{
    public static void ConfigureTenantServices(
        IServiceCollection services, 
        IConfiguration configuration)
    {
        var isEnabled = configuration.GetValue<bool>(
            TenantConstants.MultiTenancyEnabledConfigKey, true);
            
        if (isEnabled)
        {
            services.AddScoped<ITenantResolver, TenantResolver>();
            services.AddScoped<ITenantService, TenantService>();
            
            var cacheDuration = configuration.GetValue<int>(
                TenantConstants.TenantCacheDurationConfigKey, 30);
                
            services.Configure<TenantCacheOptions>(options =>
            {
                options.CacheDuration = TimeSpan.FromMinutes(cacheDuration);
            });
        }
    }
}
```

TESTING SUPPORT:
```csharp
public class TenantTestHelper
{
    public static string CreateValidTenantId() => "test-tenant-" + Guid.NewGuid().ToString("N")[..8];
    
    public static string CreateValidTenantName() => "Test Tenant " + DateTime.Now.Ticks;
    
    public static void AssertValidTenantId(string tenantId)
    {
        Assert.True(TenantConstants.IsValidTenantId(tenantId), 
            $"Tenant ID '{tenantId}' should be valid");
    }
}
```

MONITORING E METRICS:
```csharp
public class TenantMetrics
{
    private readonly IMetricsLogger _metrics;
    
    public void RecordTenantResolution(string method, bool success)
    {
        _metrics.Counter($"tenant_resolution_{method.ToLower()}")
               .WithTag("success", success.ToString())
               .Increment();
    }
    
    public void RecordCacheHit(string cacheType)
    {
        _metrics.Counter("tenant_cache_hits")
               .WithTag("type", cacheType)
               .Increment();
    }
}
```

PERFORMANCE CONSIDERATIONS:
• Use constants em vez de magic strings
• Cache frequently accessed values
• Validate input antes de database calls
• Normalize data para consistent comparisons
• Use appropriate data types
• Monitor performance metrics
• Implement circuit breakers
• Use connection pooling
• Optimize database queries
• Implement proper indexing strategies
