=================================
DOCUMENTAÇÃO TÉCNICA - ProductRepository.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/Repositories/ProductRepository.cs
CATEGORIA: Specific Repository Implementation (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
ProductRepository é uma implementação específica que herda de BaseRepository<Product>
e adiciona operações especializadas para a entidade Product. Implementa busca avançada,
filtros de negócio, operações em lote e funcionalidades específicas do domínio de produtos.

RESPONSABILIDADES:
• Herdar todas as operações CRUD básicas do BaseRepository
• Implementar busca de produtos ativos
• Fornecer busca textual avançada com múltiplos campos
• Implementar filtros por categoria e preço
• Gerenciar operações de SKU únicos
• Fornecer paginação otimizada para produtos
• Implementar operações em lote para status
• Gerar estatísticas e relatórios de produtos
• Busca avançada com múltiplos critérios

ARQUITETURA:
• Repository Pattern Specialization
• Query Builder Pattern
• Specification Pattern (via ProductSearchFilter)
• Strategy Pattern (para ordenação)
• Factory Pattern (para queries)
• Statistics Pattern
• Bulk Operations Pattern

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. OPERAÇÕES ESPECÍFICAS DE PRODUTO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO GetActiveProductsAsync():
• Filtra produtos com IsActive = true
• Exclude soft deleted automaticamente
• Ordenação por nome para consistência
• Logging de contagem de resultados
• Otimizada para UI de catálogo

MÉTODO SearchProductsAsync():
• Busca case-insensitive com EF.Functions.ILike
• Campos pesquisados: Name, Description, SKU
• Sanitização automática do termo de busca
• Ordenação por relevância (ativos primeiro)
• Empty search term handling

MÉTODO GetProductsByCategoryAsync():
• Filtro por categoria com paginação
• Parâmetro activeOnly para flexibilidade
• Validation de parâmetros de paginação
• Page size limit (max 100) para performance
• Ordenação consistente por nome

MÉTODO GetProductsByPriceRangeAsync():
• Filtro por faixa de preço
• Validation de valores negativos
• MinPrice <= MaxPrice validation
• Ordenação por preço e nome
• Support para activeOnly filter

MÉTODO GetProductBySkuAsync():
• Busca por SKU único
• Trim automático para input sanitization
• Null-safe operations
• Logging de operação de busca
• Return null para SKU não encontrado

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. BUSCA AVANÇADA E FILTERING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO AdvancedSearchAsync():
• Aceita ProductSearchFilter para múltiplos critérios
• Conditional filtering baseado em valores não-nulos
• Dynamic query building
• Multiple sort options (name, price, created)
• Paginação integrada no filtro

PRODUCTMATCHFILTER CLASS:
• SearchTerm: Busca textual em múltiplos campos
• Category: Filtro por categoria específica
• MinPrice/MaxPrice: Faixa de preço
• IsActive: Status ativo/inativo
• CreatedAfter/CreatedBefore: Range de data
• SortBy/SortDescending: Configuração de ordenação
• PageNumber/PageSize: Paginação configurável

SEARCH OPTIMIZATION:
• EF.Functions.ILike para case-insensitive search
• Index-friendly queries
• Conditional WHERE clauses
• Efficient pagination
• Memory-optimized result sets

FILTERING STRATEGY:
• Null checks before applying filters
• Trim de strings para consistency
• Validation de ranges de preço
• Date range validation
• Boolean filter handling

SORTING OPTIONS:
• Sort by name (alfabética)
• Sort by price (numérica)
• Sort by creation date (temporal)
• Ascending/descending support
• Default sort fallback

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. OPERAÇÕES DE SKU E VALIDAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO SkuExistsAsync():
• Verifica uniqueness de SKU
• ExcludeProductId para update scenarios
• Null/empty SKU handling
• Trim automático para consistency
• Logging de verificação

SKU MANAGEMENT:
• Unique constraint enforcement
• Case-sensitive comparison
• Whitespace trimming
• Update scenario support
• Validation antes de operações

BUSINESS RULES:
• SKU deve ser único no sistema
• Null/empty SKUs são permitidos
• Trim automático remove espaços
• Update operations podem manter mesmo SKU
• Validation durante create/update

ERROR PREVENTION:
• Pre-validation antes de database operations
• Clear error messages para duplicate SKUs
• Input sanitization
• Business rule enforcement
• Data integrity protection

USAGE PATTERNS:
```csharp
// Validar antes de criar
if (await _repository.SkuExistsAsync(newProduct.SKU))
{
    throw new BusinessException("SKU already exists");
}

// Validar durante update
if (await _repository.SkuExistsAsync(product.SKU, product.Id))
{
    throw new BusinessException("SKU already exists");
}
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. OPERAÇÕES EM LOTE E PERFORMANCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO UpdateActiveStatusAsync():
• Bulk update usando ExecuteUpdateAsync()
• Update de múltiplos produtos simultâneamente
• SetProperty para campos específicos
• Automatic UpdatedAt timestamp
• Return count de records afetados

BULK OPERATIONS BENEFITS:
• Single database round-trip
• Performance otimizada para large datasets
• Reduced memory usage
• Transaction-safe operations
• Minimal locking time

EXECUTE UPDATE PATTERN:
```csharp
var updatedCount = await _dbSet
    .Where(p => ids.Contains(p.Id) && !p.IsDeleted)
    .ExecuteUpdateAsync(p => p
        .SetProperty(x => x.IsActive, isActive)
        .SetProperty(x => x.UpdatedAt, DateTime.UtcNow));
```

PERFORMANCE CONSIDERATIONS:
• Avoid loading entities into memory
• Use ExecuteUpdateAsync() for bulk operations
• Minimize database round-trips
• Index-friendly WHERE clauses
• Efficient batch sizes

TRANSACTION SAFETY:
• Atomic operations via ExecuteUpdateAsync()
• Automatic rollback on failures
• Isolation level respect
• Deadlock avoidance
• Consistent state maintenance

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. ESTATÍSTICAS E RELATÓRIOS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO GetProductStatisticsAsync():
• Gera estatísticas consolidadas dos produtos
• Single query para múltiplas agregações
• Efficient groupBy(p => 1) pattern
• Null-safe aggregations
• Default fallback para empty datasets

PRODUCTSTATISTICS CLASS:
• TotalProducts: Contagem total
• ActiveProducts: Produtos ativos
• InactiveProducts: Produtos inativos
• AveragePrice: Preço médio
• MinPrice: Menor preço
• MaxPrice: Maior preço

AGGREGATION QUERY:
```csharp
var statistics = await _dbSet
    .Where(p => !p.IsDeleted)
    .GroupBy(p => 1)
    .Select(g => new ProductStatistics
    {
        TotalProducts = g.Count(),
        ActiveProducts = g.Count(p => p.IsActive),
        AveragePrice = g.Average(p => p.Price)
    })
    .FirstOrDefaultAsync();
```

BUSINESS INSIGHTS:
• Product portfolio overview
• Active vs inactive ratio
• Price distribution analysis
• Inventory management metrics
• Business intelligence data

PERFORMANCE OPTIMIZATION:
• Single query para todas as estatísticas
• Database-level aggregation
• Minimal memory usage
• Index-optimized operations
• Cached result possibilities

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. LOGGING E MONITORING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DUAL LOGGER STRATEGY:
• ILogger<BaseRepository<Product>> para operações base
• ILogger<ProductRepository> para operações específicas
• Separation of concerns no logging
• Type-safe logger injection
• Contextual log categorization

LOG CATEGORIES:
• Base operations: CRUD genérico
• Product-specific: Busca, SKU, estatísticas
• Business operations: Ativação, categorização
• Performance metrics: Query timing, result counts
• Error handling: Exception details, context

STRUCTURED LOGGING EXAMPLES:
```
[INFO] Search for 'laptop' returned 25 products
[DEBUG] Retrieved 15 active products
[WARN] Attempted to delete non-existent Product with ID 12345
[ERROR] Error updating active status for products
```

PERFORMANCE LOGGING:
• Query execution time
• Result set sizes
• Cache hit/miss ratios
• Database round-trip counts
• Memory usage patterns

BUSINESS METRICS:
• Search term popularity
• Category access patterns
• Price range queries
• SKU validation frequency
• Bulk operation success rates

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. QUERY OPTIMIZATION E INDEXES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

INDEX RECOMMENDATIONS:
• IX_Products_IsDeleted_IsActive para filtros comuns
• IX_Products_SKU único para uniqueness
• IX_Products_Category para filtros por categoria
• IX_Products_Price para range queries
• IX_Products_Name para ordenação

QUERY PATTERNS:
• EF.Functions.ILike para case-insensitive search
• Contains() para partial string matching
• Range queries com >= e <=
• Compound WHERE clauses
• Efficient ORDER BY patterns

PERFORMANCE TECHNIQUES:
• AsNoTracking() onde apropriado
• Projection para selected fields only
• Batching para large operations
• Connection pooling
• Query plan caching

MEMORY OPTIMIZATION:
• Streaming para large result sets
• Pagination para UI responsiveness
• Disposal pattern implementation
• Garbage collection friendly
• Connection lifecycle management

DATABASE HINTS:
• Entity Framework query translation
• SQL Server optimization
• PostgreSQL specific features
• Index usage monitoring
• Query execution plans

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. DEPENDENCY INJECTION E TESTING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONSTRUCTOR INJECTION:
• ApplicationDbContext para database access
• ILogger<BaseRepository<Product>> para base logging
• ILogger<ProductRepository> para specific logging
• Validation de null parameters
• Proper inheritance chain

DI REGISTRATION:
```csharp
services.AddScoped<IProductRepository, ProductRepository>();
services.AddScoped<ILogger<BaseRepository<Product>>>();
services.AddScoped<ILogger<ProductRepository>>();
```

INTERFACE IMPLEMENTATION:
• IProductRepository extends IRepository<Product>
• Specific methods addition
• Liskov Substitution Principle
• Interface segregation
• Dependency inversion

TESTING SUPPORT:
• Constructor overloads para unit tests
• Mock-friendly design
• In-memory database support
• Integration test ready
• Behavior verification

MOCK STRATEGIES:
```csharp
var mockContext = new Mock<ApplicationDbContext>();
var mockBaseLogger = new Mock<ILogger<BaseRepository<Product>>>();
var mockProductLogger = new Mock<ILogger<ProductRepository>>();

var repository = new ProductRepository(
    mockContext.Object, 
    mockBaseLogger.Object, 
    mockProductLogger.Object);
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO E INTEGRAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

SERVICE INTEGRATION:
```csharp
public class ProductService
{
    private readonly IProductRepository _productRepository;
    
    public ProductService(IProductRepository productRepository)
    {
        _productRepository = productRepository;
    }
    
    public async Task<IEnumerable<Product>> GetCatalogProductsAsync()
    {
        return await _productRepository.GetActiveProductsAsync();
    }
    
    public async Task<IEnumerable<Product>> SearchProductsAsync(string term)
    {
        return await _productRepository.SearchProductsAsync(term);
    }
}
```

CONTROLLER USAGE:
```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repository;
    
    [HttpGet("active")]
    public async Task<IActionResult> GetActiveProducts()
    {
        var products = await _repository.GetActiveProductsAsync();
        return Ok(products);
    }
    
    [HttpGet("search")]
    public async Task<IActionResult> SearchProducts([FromQuery] string term)
    {
        var products = await _repository.SearchProductsAsync(term);
        return Ok(products);
    }
    
    [HttpGet("statistics")]
    public async Task<IActionResult> GetStatistics()
    {
        var stats = await _repository.GetProductStatisticsAsync();
        return Ok(stats);
    }
}
```

ADVANCED SEARCH USAGE:
```csharp
public async Task<IEnumerable<Product>> AdvancedProductSearchAsync(
    string searchTerm,
    string category,
    decimal? minPrice,
    decimal? maxPrice,
    bool? isActive,
    int pageNumber = 1,
    int pageSize = 20)
{
    var filter = new ProductSearchFilter
    {
        SearchTerm = searchTerm,
        Category = category,
        MinPrice = minPrice,
        MaxPrice = maxPrice,
        IsActive = isActive,
        PageNumber = pageNumber,
        PageSize = pageSize,
        SortBy = "name",
        SortDescending = false
    };
    
    return await _repository.AdvancedSearchAsync(filter);
}
```

SKU VALIDATION:
```csharp
public async Task<Product> CreateProductAsync(Product product)
{
    // Validar SKU único antes de criar
    if (!string.IsNullOrWhiteSpace(product.SKU))
    {
        var skuExists = await _repository.SkuExistsAsync(product.SKU);
        if (skuExists)
        {
            throw new BusinessException($"SKU '{product.SKU}' already exists");
        }
    }
    
    return await _repository.AddAsync(product);
}
```

BULK OPERATIONS:
```csharp
public async Task<int> ActivateProductsByCategoryAsync(string category)
{
    // Buscar produtos da categoria
    var products = await _repository.GetProductsByCategoryAsync(category, activeOnly: false);
    var productIds = products.Select(p => p.Id);
    
    // Ativar em lote
    return await _repository.UpdateActiveStatusAsync(productIds, true);
}
```

STATISTICS DASHBOARD:
```csharp
public async Task<ProductDashboard> GetDashboardDataAsync()
{
    var statistics = await _repository.GetProductStatisticsAsync();
    var activeProducts = await _repository.GetActiveProductsAsync();
    
    return new ProductDashboard
    {
        Statistics = statistics,
        RecentActiveProducts = activeProducts.Take(10),
        Categories = activeProducts.GroupBy(p => p.Category)
                                 .Select(g => new { Category = g.Key, Count = g.Count() })
    };
}
```

BEST PRACTICES:
• Use specific repository methods quando disponíveis
• Implement input validation antes de chamar repository
• Handle null results appropriadamente
• Use pagination para large datasets
• Implement caching em service layer quando apropriado
• Monitor performance de queries complexas
• Use bulk operations para multiple updates
• Validate business rules antes de persistence
• Implement retry logic para transient failures
• Log important business operations
