=================================
DOCUMENTAÇÃO TÉCNICA - BaseRepository.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/Repositories/BaseRepository.cs
CATEGORIA: Generic Repository Pattern (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
BaseRepository é um repositório genérico que implementa operações CRUD comuns
para todas as entidades que herdam de BaseEntity. Fornece uma base sólida
com suporte a soft delete, multi-tenancy, logging estruturado, paginação
e operações assíncronas otimizadas.

RESPONSABILIDADES:
• Implementar operações CRUD genéricas para todas as entidades
• Gerenciar soft delete automaticamente
• Fornecer logging estruturado para auditoria
• Implementar paginação e busca otimizada
• Suportar operações em lote para performance
• Gerenciar timestamps automaticamente
• Implementar error handling robusto
• Fornecer base para repositórios específicos

ARQUITETURA:
• Generic Repository Pattern
• Unit of Work Pattern Integration
• Specification Pattern Ready
• Structured Logging Pattern
• Async/Await Pattern
• Template Method Pattern
• Error Handling Strategy

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. OPERAÇÕES CRUD BÁSICAS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO GetByIdAsync():
• Busca entidade por ID excluindo soft deleted
• Async/await para performance não-bloqueante
• Logging automático de operações
• Null-safe com tratamento adequado
• Exception handling com contexto

MÉTODO GetAllAsync():
• Retorna todas as entidades não soft deleted
• Otimizado para datasets pequenos/médios
• Logging de contagem de resultados
• Filtro automático de IsDeleted = false
• Error handling abrangente

MÉTODO GetPagedAsync():
• Paginação eficiente com Skip/Take
• Validação de parâmetros de entrada
• Otimizada para grandes datasets
• Logging de métricas de paginação
• Support para diferentes page sizes

MÉTODO FindAsync():
• Busca por predicado customizável
• Expression tree optimization
• Combina com filtro de soft delete
• Flexible query building
• Performance optimized

MÉTODO FindFirstAsync():
• Busca primeira entidade que atende critério
• Otimizada para single result
• FirstOrDefault pattern
• Predicate validation
• Null-safe operations

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. OPERAÇÕES DE INSERÇÃO E ATUALIZAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO AddAsync():
• Adiciona single entity com timestamp automático
• CreatedAt e UpdatedAt configurados automaticamente
• SaveChanges integrado na operação
• Logging de operação com ID da entidade
• Exception handling com rollback automático

MÉTODO AddRangeAsync():
• Inserção em lote para performance
• Timestamp consistente para todo o lote
• Validation de lista não-vazia
• Logging de métricas de batch
• Otimizada para bulk operations

MÉTODO UpdateAsync():
• Atualização de entidade existente
• UpdatedAt timestamp automático
• Change tracking otimizado
• Audit logging automático
• Concurrency handling

TIMESTAMP MANAGEMENT:
• CreatedAt: Configurado apenas na criação
• UpdatedAt: Atualizado em create e update
• UTC timezone para consistência
• Immutable após criação (CreatedAt)
• Auditoria completa de mudanças

BATCH OPERATIONS:
• AddRangeAsync() para múltiplas entidades
• Performance optimized para bulk insert
• Consistent timestamp para todo o batch
• Error handling para partial failures
• Transaction scope automático

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. SOFT DELETE IMPLEMENTATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO DeleteAsync():
• Soft delete via IsDeleted flag
• Preserva dados para auditoria
• UpdatedAt timestamp automático
• Não remove fisicamente do banco
• Logging de operação de exclusão

MÉTODO DeleteByIdAsync():
• Soft delete por ID
• Verifica existência antes de deletar
• Return boolean para success/failure
• Otimizada para single ID operations
• Warning log para entidades inexistentes

SOFT DELETE STRATEGY:
• IsDeleted = true marca como excluída
• Dados permanecem no banco
• Filtro automático em todas as queries
• Permite recuperação se necessário
• Compliance com auditorias

FILTERING AUTOMÁTICO:
• Where(e => !e.IsDeleted) aplicado automaticamente
• Transparente para código client
• Consistente em todas as operações
• Override possível em repositórios específicos
• Performance optimized via indices

RECOVERY OPERATIONS:
• Possível implementar UndeleteAsync()
• Audit trail completo mantido
• Restauração de relacionamentos
• Validation de integridade
• Logging de operações de recuperação

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. LOGGING E AUDITORIA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

STRUCTURED LOGGING:
• ILogger<BaseRepository<T>> para type safety
• Parâmetros estruturados para searchability
• Different log levels apropriados
• Context information em todos os logs
• Performance metrics incluídas

LOG LEVELS:
• LogDebug: Operações de busca successful
• LogInformation: Create, Update, Delete operations
• LogWarning: Tentativas de operação em dados inexistentes
• LogError: Exceptions e failures

AUDIT INFORMATION:
• Entity type name em todos os logs
• Entity ID quando disponível
• Operation type (Create, Read, Update, Delete)
• Timestamp de operação
• Performance metrics

EXEMPLO DE LOG:
```
[INFO] Added new Product with ID 12345678-1234-1234-1234-123456789012
[DEBUG] Retrieved page 1 with 20 entities of type Product
[ERROR] Error updating Product with ID 12345678-1234-1234-1234-123456789012
```

CORRELATION LOGGING:
• Request correlation via scoped services
• Transaction boundary logging
• Cross-service call tracing
• Performance bottleneck identification
• Error correlation e troubleshooting

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. PERFORMANCE E OTIMIZAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ASYNC/AWAIT PATTERNS:
• Todas as operações são async
• ConfigureAwait(false) onde apropriado
• CancellationToken support em todos os métodos
• Non-blocking operations
• Scalable para high-concurrency

QUERY OPTIMIZATION:
• Projection apenas de campos necessários
• Index hints via Entity Framework
• Batching para operations múltiplas
• Connection pooling automático
• Query plan caching

PAGINATION STRATEGY:
• Skip/Take para offset pagination
• Validation de parâmetros
• Maximum page size enforcement
• Index-friendly ordering
• Memory efficient processing

BATCH OPERATIONS:
• AddRangeAsync() para bulk inserts
• ExecuteUpdateAsync() para bulk updates
• Minimize database roundtrips
• Transaction scope otimizado
• Memory management eficiente

MEMORY MANAGEMENT:
• Dispose pattern implementation
• IQueryable vs IEnumerable appropriado
• Streaming para large datasets
• Garbage collection friendly
• Connection lifecycle management

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. ERROR HANDLING E RESILIENCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

EXCEPTION HANDLING:
• Try-catch em todas as operações críticas
• Specific exception types quando apropriado
• Context information em exceptions
• Logging antes de re-throw
• Graceful degradation

EXCEPTION TYPES:
• ArgumentNullException para parâmetros obrigatórios
• ArgumentException para valores inválidos
• InvalidOperationException para estado inválido
• DbUpdateConcurrencyException para conflicts
• DbUpdateException para database errors

VALIDATION STRATEGIES:
• Parameter validation em method entry
• Business rule validation
• Database constraint validation
• Type safety via generics
• Null safety patterns

RETRY LOGIC:
• Built-in Entity Framework retry policies
• Transient failure detection
• Exponential backoff strategies
• Circuit breaker pattern ready
• Dead letter queue support

TRANSACTION MANAGEMENT:
• SaveChangesAsync() com transaction scope
• Rollback automático em failures
• Isolation level configuration
• Deadlock detection e retry
• Distributed transaction support

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. EXTENSIBILIDADE E CUSTOMIZAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

VIRTUAL METHODS:
• Todos os methods são virtual para override
• Template method pattern implementation
• Customization points bem definidos
• Backward compatibility mantida
• Extension friendly design

PROTECTED MEMBERS:
• _context e _dbSet accessible para subclasses
• GetBaseQuery() para query customization
• SaveChangesAsync() para transaction control
• Extension points para business logic
• Custom filtering implementation

GENERIC CONSTRAINTS:
• where T : BaseEntity para type safety
• Ensures soft delete support
• Audit fields availability
• Consistent behavior across entities
• Compile-time validation

REPOSITORY INHERITANCE:
• ProductRepository : BaseRepository<Product>
• Specific methods addition
• Base functionality reuse
• Polymorphic behavior
• Interface segregation

CUSTOMIZATION EXAMPLES:
```csharp
public class ProductRepository : BaseRepository<Product>
{
    protected override IQueryable<Product> GetBaseQuery()
    {
        return base.GetBaseQuery()
            .Where(p => p.TenantId == _currentTenant.Id);
    }
}
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. DEPENDENCY INJECTION E CONFIGURATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONSTRUCTOR DEPENDENCIES:
• ApplicationDbContext para database access
• ILogger<BaseRepository<T>> para logging
• Validation de null parameters
• Dependency injection ready
• Scoped lifetime apropriado

DI REGISTRATION:
```csharp
services.AddScoped(typeof(IRepository<>), typeof(BaseRepository<>));
services.AddScoped<IProductRepository, ProductRepository>();
```

LIFETIME MANAGEMENT:
• Scoped lifetime para request boundary
• DbContext sharing within scope
• Memory management automático
• Connection pooling integration
• Disposal pattern implementation

CONFIGURATION OPTIONS:
• Connection string via configuration
• Logging configuration
• Performance settings
• Timeout configuration
• Retry policy settings

TESTING SUPPORT:
• Constructor overloads para testing
• Mock-friendly design
• In-memory database support
• Integration test ready
• Unit test isolation

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

USO BÁSICO:
```csharp
public class ProductService
{
    private readonly IRepository<Product> _repository;
    
    public ProductService(IRepository<Product> repository)
    {
        _repository = repository;
    }
    
    public async Task<Product?> GetProductAsync(Guid id)
    {
        return await _repository.GetByIdAsync(id);
    }
    
    public async Task<IEnumerable<Product>> GetPagedProductsAsync(int page, int size)
    {
        return await _repository.GetPagedAsync(page, size);
    }
    
    public async Task<Product> CreateProductAsync(Product product)
    {
        return await _repository.AddAsync(product);
    }
}
```

BUSCA COM PREDICADO:
```csharp
// Buscar produtos ativos
var activeProducts = await _repository.FindAsync(p => p.IsActive);

// Buscar por categoria
var categoryProducts = await _repository.FindAsync(p => p.Category == "Electronics");

// Buscar primeira entidade
var firstExpensive = await _repository.FindFirstAsync(p => p.Price > 1000);
```

OPERAÇÕES EM LOTE:
```csharp
// Inserção em lote
var products = new List<Product> { product1, product2, product3 };
await _repository.AddRangeAsync(products);

// Soft delete
await _repository.DeleteByIdAsync(productId);

// Verificar existência
var exists = await _repository.ExistsAsync(productId);
```

PAGINAÇÃO:
```csharp
// Primeira página
var firstPage = await _repository.GetPagedAsync(1, 20);

// Contagem para pagination UI
var totalCount = await _repository.CountAsync();

// Contagem com filtro
var activeCount = await _repository.CountAsync(p => p.IsActive);
```

REPOSITÓRIO CUSTOMIZADO:
```csharp
public class ProductRepository : BaseRepository<Product>, IProductRepository
{
    public ProductRepository(ApplicationDbContext context, ILogger<BaseRepository<Product>> logger)
        : base(context, logger) { }
    
    public async Task<IEnumerable<Product>> GetActiveProductsAsync()
    {
        return await FindAsync(p => p.IsActive);
    }
    
    protected override IQueryable<Product> GetBaseQuery()
    {
        // Adicionar filtros específicos
        return base.GetBaseQuery().Where(p => p.TenantId == _currentTenant.Id);
    }
}
```

BEST PRACTICES:
• Sempre usar async/await para operações de banco
• Implement logging em operações críticas
• Use paginação para large datasets
• Implement proper error handling
• Use CancellationToken para operações longas
• Validate parâmetros de entrada
• Use batching para múltiplas operações
• Monitor performance metrics
• Implement circuit breaker para resilience
• Use connection pooling para performance
