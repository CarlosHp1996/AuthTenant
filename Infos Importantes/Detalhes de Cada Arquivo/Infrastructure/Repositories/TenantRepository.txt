=================================
DOCUMENTAÇÃO TÉCNICA - TenantRepository.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/Repositories/TenantRepository.cs
CATEGORIA: Tenant Management Repository (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
TenantRepository é uma implementação específica para gerenciamento de tenants
em uma arquitetura multi-tenant. Implementa cache em memória para otimização,
operações CRUD completas, validação de unicidade, e funcionalidades avançadas
como estatísticas, paginação e operações em lote.

RESPONSABILIDADES:
• Gerenciar operações CRUD de tenants
• Implementar cache em memória para performance
• Validar restrições de unicidade (ID e Nome)
• Fornecer busca por ID e nome
• Implementar operações de ativação/desativação
• Gerar estatísticas de tenants
• Suportar paginação para listagens
• Gerenciar invalidação de cache
• Implementar operações de existência
• Fornecer hard delete quando necessário

ARQUITETURA:
• Repository Pattern Implementation
• Caching Strategy Pattern
• Validation Pattern
• Statistics Pattern
• Bulk Operations Pattern
• Cache Invalidation Strategy
• Dual Key Access Pattern

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. ESTRATÉGIA DE CACHE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CACHE CONFIGURATION:
• IMemoryCache para armazenamento em memória
• Cache duration: 30 minutos para entidades
• Cache duration: 15 minutos para listas
• Cache keys: "tenant_id_{id}" e "tenant_name_{name}"
• Cache invalidation automática em mudanças

CACHE STRATEGY:
• Cache-first pattern para reads
• Cache warming em database hits
• Dual key caching (por ID e nome)
• Automatic cache invalidation
• Memory pressure handling

CACHE KEYS:
```csharp
GetCacheKey("id", tenantId)     // "tenant_id_12345"
GetCacheKey("name", name)       // "tenant_name_company"
"all_active_tenants"            // Lista de tenants ativos
```

CACHE BENEFITS:
• Redução de database round-trips
• Melhoria de performance para tenant resolution
• Menor latência em operações de validação
• Escalabilidade para múltiplos tenants
• Redução de carga no banco de dados

CACHE INVALIDATION:
• Manual via InvalidateRelatedCaches()
• Automática em Create, Update, Delete
• Bulk invalidation para operações em lote
• Memory pressure automatic cleanup
• TTL-based expiration

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. OPERAÇÕES DE BUSCA E ACESSO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO GetByIdAsync():
• Busca tenant por ID com cache otimizado
• Cache-first pattern implementation
• AsNoTracking() para performance
• Dual cache (cache hit armazena por ID)
• Null-safe operations

MÉTODO GetByNameAsync():
• Busca case-insensitive com EF.Functions.ILike
• Cache por nome normalizado (lowercase)
• Dual caching (por nome e ID)
• Input sanitization e validation
• Null/empty name handling

MÉTODO GetAllActiveAsync():
• Lista todos os tenants ativos
• Cache de lista com TTL menor (15 min)
• Ordenação por nome para consistência
• AsNoTracking() para performance
• Single query result caching

MÉTODO GetPagedAsync():
• Paginação eficiente com validation
• ActiveOnly parameter para filtering
• Page size limits (max 100)
• Efficient Skip/Take operations
• Consistent ordering por nome

PERFORMANCE OPTIMIZATIONS:
• AsNoTracking() para read-only queries
• Single query para multiple data points
• Index-friendly WHERE clauses
• Efficient ordering strategies
• Memory-optimized projections

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. OPERAÇÕES CRUD E VALIDATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO CreateAsync():
• Validação de unique constraints
• Automatic timestamp setting
• Cache invalidation pós-criação
• Business rule validation
• Error handling with context

MÉTODO UpdateAsync():
• Existence validation antes de update
• Automatic UpdatedAt timestamp
• Cache invalidation comprehensive
• Change tracking optimization
• Audit logging integration

MÉTODO SetActiveStatusAsync():
• Bulk status update com ExecuteUpdateAsync()
• Efficient single-query operation
• Cache invalidation targeted
• Return affected row count
• Audit logging de status changes

VALIDATION METHODS:
• ValidateUniqueConstraintsAsync() para ID e Nome
• NameExistsAsync() com exclude parameter
• ExistsAsync() com cache optimization
• Input validation em todos os entry points
• Business rule enforcement

UNIQUE CONSTRAINTS:
• Tenant ID deve ser único
• Tenant Name deve ser único (case-insensitive)
• Validation durante Create operations
• Update operations preservam uniqueness
• Clear error messages para violations

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. ESTATÍSTICAS E ANALYTICS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO GetStatisticsAsync():
• Single query para múltiplas agregações
• TenantStatistics class para result
• Efficient GroupBy(t => 1) pattern
• Default fallback para empty datasets
• Business intelligence data

TENANTSTATISTICS CLASS:
• TotalTenants: Contagem total
• ActiveTenants: Tenants ativos
• InactiveTenants: Tenants inativos
• Extensible para novas métricas
• Strongly-typed result object

AGGREGATION QUERY:
```csharp
var statistics = await _context.Tenants
    .GroupBy(t => 1)
    .Select(g => new TenantStatistics
    {
        TotalTenants = g.Count(),
        ActiveTenants = g.Count(t => t.IsActive),
        InactiveTenants = g.Count(t => !t.IsActive)
    })
    .FirstOrDefaultAsync();
```

BUSINESS INSIGHTS:
• Tenant adoption metrics
• Active vs inactive ratios
• Growth trending data
• Capacity planning information
• Usage analytics foundation

PERFORMANCE CONSIDERATIONS:
• Single database query
• Server-side aggregation
• Minimal memory footprint
• Index-optimized operations
• Cacheable results

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. OPERAÇÕES EM LOTE E PERFORMANCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

BULK UPDATE OPERATIONS:
• SetActiveStatusAsync() para status em lote
• ExecuteUpdateAsync() para performance
• Minimal database round-trips
• Transaction-safe operations
• Efficient memory usage

EXECUTEUPDATE PATTERN:
```csharp
var rowsAffected = await _context.Tenants
    .Where(t => t.Id == tenantId)
    .ExecuteUpdateAsync(t => t
        .SetProperty(x => x.IsActive, isActive)
        .SetProperty(x => x.UpdatedAt, DateTime.UtcNow));
```

CACHE MANAGEMENT:
• Selective cache invalidation
• Bulk invalidation strategies
• Memory pressure handling
• Cache warming strategies
• Performance monitoring

TRANSACTION STRATEGIES:
• Automatic transaction scoping
• Rollback em caso de failure
• Isolation level configuration
• Deadlock avoidance
• Consistent state maintenance

PERFORMANCE OPTIMIZATIONS:
• AsNoTracking() para read operations
• Efficient query patterns
• Index-friendly operations
• Connection pooling
• Query plan caching

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. LOGGING E MONITORING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

STRUCTURED LOGGING:
• ILogger<TenantRepository> para type safety
• Structured parameters para searchability
• Different log levels apropriados
• Context information em todos os logs
• Performance metrics incluídas

LOG LEVELS STRATEGY:
• LogDebug: Cache hits, query results, existence checks
• LogInformation: Create, Update, Status changes
• LogWarning: Attempted operations em non-existent tenants
• LogError: Exceptions, database errors, validation failures

CACHE LOGGING:
• Cache hit/miss logging
• Cache invalidation events
• Memory pressure notifications
• Cache performance metrics
• Troubleshooting information

AUDIT LOGGING:
• Tenant creation events
• Status change operations
• Delete operations (permanent)
• Failed validation attempts
• Security-relevant events

PERFORMANCE LOGGING:
• Query execution times
• Result set sizes
• Cache effectiveness metrics
• Database round-trip counts
• Memory usage patterns

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. HARD DELETE E DATA MANAGEMENT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODO DeleteAsync():
• Hard delete permanente (não soft delete)
• Warning log para operação perigosa
• Existence validation antes de delete
• Comprehensive cache invalidation
• Return boolean para success/failure

HARD DELETE CONSIDERATIONS:
• Permanent data removal
• Cannot be undone
• Affects referential integrity
• Cascade delete implications
• Audit trail considerations

SAFETY MEASURES:
• Existence check antes de delete
• Warning level logging
• Return value indicates success
• Exception handling para constraints
• Audit logging da operação

DATA INTEGRITY:
• Foreign key constraint handling
• Cascade delete configuration
• Orphaned data prevention
• Referential integrity maintenance
• Clean deletion process

USAGE SCENARIOS:
• Admin operations apenas
• Cleanup de test data
• GDPR compliance deletion
• Data retention policy enforcement
• System maintenance operations

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. DEPENDENCY INJECTION E TESTING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONSTRUCTOR DEPENDENCIES:
• ApplicationDbContext para database access
• IMemoryCache para caching strategy
• ILogger<TenantRepository> para logging
• Validation de null parameters
• Proper dependency injection

DI REGISTRATION:
```csharp
services.AddScoped<ITenantRepository, TenantRepository>();
services.AddMemoryCache();
services.AddLogging();
services.AddDbContext<ApplicationDbContext>();
```

INTERFACE IMPLEMENTATION:
• ITenantRepository interface implementation
• Additional methods beyond interface
• Extension methods compatibility
• Service contract fulfillment
• Behavioral consistency

TESTING STRATEGIES:
• Mock IMemoryCache para unit tests
• In-memory database para integration tests
• Logger mock para behavior verification
• Dependency injection container tests
• Performance testing scenarios

MOCK EXAMPLE:
```csharp
var mockContext = new Mock<ApplicationDbContext>();
var mockCache = new Mock<IMemoryCache>();
var mockLogger = new Mock<ILogger<TenantRepository>>();

var repository = new TenantRepository(
    mockContext.Object,
    mockCache.Object,
    mockLogger.Object);
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO E INTEGRAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TENANT RESOLUTION SERVICE:
```csharp
public class CurrentTenantService : ICurrentTenantService
{
    private readonly ITenantRepository _tenantRepository;
    
    public async Task<Tenant?> GetCurrentTenantAsync()
    {
        var tenantId = ResolveTenantId();
        return await _tenantRepository.GetByIdAsync(tenantId);
    }
    
    public async Task<bool> ValidateTenantAsync(string tenantId)
    {
        return await _tenantRepository.ExistsAsync(tenantId);
    }
}
```

TENANT MANAGEMENT SERVICE:
```csharp
public class TenantManagementService
{
    private readonly ITenantRepository _tenantRepository;
    
    public async Task<Tenant> CreateTenantAsync(CreateTenantRequest request)
    {
        // Validar unicidade
        if (await _tenantRepository.NameExistsAsync(request.Name))
        {
            throw new BusinessException("Tenant name already exists");
        }
        
        var tenant = new Tenant
        {
            Id = request.Id,
            Name = request.Name,
            IsActive = true
        };
        
        return await _tenantRepository.CreateAsync(tenant);
    }
    
    public async Task<bool> ActivateTenantAsync(string tenantId)
    {
        return await _tenantRepository.SetActiveStatusAsync(tenantId, true);
    }
}
```

ADMIN CONTROLLER:
```csharp
[ApiController]
[Route("api/admin/[controller]")]
public class TenantsController : ControllerBase
{
    private readonly ITenantRepository _tenantRepository;
    
    [HttpGet]
    public async Task<IActionResult> GetTenants(
        [FromQuery] int page = 1, 
        [FromQuery] int size = 20,
        [FromQuery] bool activeOnly = false)
    {
        var tenants = await _tenantRepository.GetPagedAsync(page, size, activeOnly);
        return Ok(tenants);
    }
    
    [HttpGet("statistics")]
    public async Task<IActionResult> GetStatistics()
    {
        var stats = await _tenantRepository.GetStatisticsAsync();
        return Ok(stats);
    }
    
    [HttpPost("{id}/activate")]
    public async Task<IActionResult> ActivateTenant(string id)
    {
        var success = await _tenantRepository.SetActiveStatusAsync(id, true);
        return success ? Ok() : NotFound();
    }
}
```

TENANT VALIDATION MIDDLEWARE:
```csharp
public class TenantValidationMiddleware
{
    private readonly ITenantRepository _tenantRepository;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var tenantId = ExtractTenantId(context);
        
        if (!string.IsNullOrEmpty(tenantId))
        {
            var tenant = await _tenantRepository.GetByIdAsync(tenantId);
            if (tenant == null || !tenant.IsActive)
            {
                context.Response.StatusCode = 404;
                return;
            }
        }
        
        await _next(context);
    }
}
```

BACKGROUND SERVICE:
```csharp
public class TenantStatsCollectorService : BackgroundService
{
    private readonly ITenantRepository _tenantRepository;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var stats = await _tenantRepository.GetStatisticsAsync();
            
            // Send to monitoring system
            await PublishTenantMetrics(stats);
            
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
}
```

SEARCH AND FILTER:
```csharp
public async Task<IEnumerable<Tenant>> SearchTenantsAsync(
    string searchTerm,
    bool? isActive = null,
    int pageNumber = 1,
    int pageSize = 20)
{
    if (!string.IsNullOrWhiteSpace(searchTerm))
    {
        var tenant = await _tenantRepository.GetByNameAsync(searchTerm);
        if (tenant != null && (!isActive.HasValue || tenant.IsActive == isActive.Value))
        {
            return new[] { tenant };
        }
    }
    
    return await _tenantRepository.GetPagedAsync(pageNumber, pageSize, isActive ?? false);
}
```

BEST PRACTICES:
• Use cache-aware patterns para frequently accessed tenants
• Implement proper error handling para tenant operations
• Monitor cache hit ratios para performance optimization
• Use bulk operations para multiple tenant updates
• Implement proper audit logging para security compliance
• Validate tenant uniqueness constraints antes de operations
• Use paginação para large tenant lists
• Implement circuit breaker para database resilience
• Monitor tenant statistics para capacity planning
• Use structured logging para troubleshooting e analytics
