=================================
DOCUMENTAÇÃO TÉCNICA - ApplicationDbContextFactory.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/Data/ApplicationDbContextFactory.cs
CATEGORIA: Design-Time Factory (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
ApplicationDbContextFactory é uma factory de design-time que permite ao Entity Framework
Core criar instâncias do ApplicationDbContext durante operações de desenvolvimento,
como criação de migrações, atualizações de banco de dados e outras ferramentas EF.
É essencial para suporte multi-tenant em ambiente de desenvolvimento.

RESPONSABILIDADES:
• Criar instâncias de ApplicationDbContext para design-time
• Fornecer configuração adequada para ferramentas EF Core
• Implementar services mock para desenvolvimento
• Resolver dependências sem container DI
• Configurar connection string para desenvolvimento
• Suportar operações de migration e scaffolding

ARQUITETURA:
• Factory Pattern para criação de contexto
• Design-Time Services Pattern
• Configuration Builder Pattern
• Dependency Injection Simulation

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. ESTRUTURA TÉCNICA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

IMPLEMENTAÇÃO PRINCIPAL:
• IDesignTimeDbContextFactory<ApplicationDbContext>
• Método CreateDbContext() para criação de instâncias
• Configuração de serviços mock para design-time
• Resolução de connection string via appsettings

CLASSES AUXILIARES:
• DesignTimeCurrentTenantService: Mock de ICurrentTenantService
• DesignTimeHttpContextAccessor: Mock de IHttpContextAccessor  
• DesignTimeLogger: Mock de ILogger<ApplicationDbContext>

CONFIGURAÇÃO:
• ConfigurationBuilder para carregar appsettings
• DbContextOptionsBuilder para PostgreSQL
• Resolução de path relativo para arquivos de config
• Suporte a environment-specific settings

DEPENDÊNCIAS RESOLVIDAS:
• Entity Framework Core
• PostgreSQL provider (Npgsql)
• Microsoft.Extensions.Configuration
• ASP.NET Core abstractions

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. FACTORY PRINCIPAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CREATEDBCONTEXT():
• Carrega configuração de appsettings.json
• Configura PostgreSQL como provider
• Cria services mock necessários
• Retorna ApplicationDbContext funcional

CONFIGURAÇÃO DE SETTINGS:
• SetBasePath() para localizar arquivos de config
• Suporte a appsettings.Development.json
• Fallback graceful se arquivos não existirem
• Path relativo para projeto API

CONNECTION STRING:
• Resolve "DefaultConnection" dos appsettings
• Configura UseNpgsql() com string adequada
• Suporte a diferentes ambientes
• Configuração otimizada para desenvolvimento

CRIAÇÃO DE SERVICES:
• DesignTimeCurrentTenantService com tenant padrão
• DesignTimeHttpContextAccessor sem contexto HTTP
• DesignTimeLogger com logging desabilitado
• Instanciação manual sem container DI

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. DESIGN-TIME TENANT SERVICE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

IMPLEMENTAÇÃO MOCK:
• TenantId fixo como "default"
• HasValidTenant sempre retorna true
• SetTenant() não implementado (design-time)
• GetCurrentTenantAsync() retorna tenant padrão

TENANT PADRÃO:
• Id: "default" - Identificador do sistema
• Name: "default" - Nome técnico
• DisplayName: "Default Tenant" - Nome amigável
• IsActive: true - Sempre ativo
• CreatedAt: DateTime.UtcNow - Timestamp atual

PROPÓSITO:
• Permitir operações EF que requerem tenant context
• Evitar exceções durante migrações
• Fornecer contexto mínimo para desenvolvimento
• Garantir consistência com tenant real

LIMITAÇÕES:
• Não suporta mudança dinâmica de tenant
• Não implementa validações complexas
• Focado apenas em operações de desenvolvimento
• Não persiste estado entre operações

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. DESIGN-TIME HTTP CONTEXT ACCESSOR
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

IMPLEMENTAÇÃO MINIMALISTA:
• HttpContext sempre null
• Não há contexto HTTP em design-time
• Satisfaz requisito de dependência
• Evita exceções de null reference

PROPÓSITO:
• Permitir instanciação de ApplicationDbContext
• Satisfazer injection de IHttpContextAccessor
• Suportar operações que não requerem HTTP context
• Manter compatibilidade com runtime

COMPORTAMENTO:
• GetCurrentUserId() retornará null
• Operações de auditoria usarão defaults
• Não há informações de usuário autenticado
• Adequado para operações automáticas

USO TÍPICO:
• Migrações de banco de dados
• Scaffolding de entidades
• Seed de dados inicial
• Operações de desenvolvimento

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. DESIGN-TIME LOGGER
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

IMPLEMENTAÇÃO NO-OP:
• IsEnabled() sempre retorna false
• Log() não executa operação alguma
• BeginScope() retorna null
• Overhead mínimo de performance

JUSTIFICATIVA:
• Design-time não requer logging complexo
• EF tools têm seu próprio logging
• Evita configuração complexa de logging
• Reduz ruído durante desenvolvimento

ALTERNATIVAS:
• Console logging para debug se necessário
• File logging para análise de migrações
• Structured logging para análise avançada
• Integration com ferramentas EF existentes

EXTENSIBILIDADE:
• Pode ser estendido para logging específico
• Configuração condicional baseada em argumentos
• Suporte a diferentes providers de log
• Integration com sistemas de monitoramento

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. USO COM FERRAMENTAS EF CORE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MIGRATIONS:
• dotnet ef migrations add <name>
• dotnet ef migrations remove
• dotnet ef migrations list
• dotnet ef migrations script

DATABASE UPDATE:
• dotnet ef database update
• dotnet ef database update <migration>
• dotnet ef database drop
• dotnet ef database drop --force

SCAFFOLDING:
• dotnet ef dbcontext scaffold
• dotnet ef dbcontext info
• dotnet ef dbcontext list
• dotnet ef dbcontext script

CONFIGURAÇÃO AUTOMÁTICA:
• EF Core descobre automaticamente a factory
• Não requer configuração adicional
• Funciona com CLI tools e Package Manager Console
• Suporte a múltiplos contextos

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. CONFIGURAÇÃO E AMBIENTES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

HIERARCHY DE CONFIGURAÇÃO:
1. appsettings.json (base)
2. appsettings.Development.json (ambiente)
3. Variáveis de ambiente (override)
4. Command line arguments (prioridade máxima)

CONNECTION STRINGS:
• "DefaultConnection" para desenvolvimento
• Suporte a PostgreSQL connection string
• Configuração específica por ambiente
• Override via environment variables

PATHS E LOCALIZAÇÕES:
• SetBasePath() relativo ao projeto API
• Busca automática de arquivos de configuração
• Fallback para configuração mínima
• Compatibilidade com diferentes estruturas

EXTENSIBILIDADE:
• Fácil adição de novos ambientes
• Suporte a providers alternativos
• Configuração condicional baseada em argumentos
• Integration com Azure, AWS, etc.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. TROUBLESHOOTING E DEBUGGING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PROBLEMAS COMUNS:
• Connection string não encontrada
• Arquivos de configuração ausentes
• Path incorreto para appsettings
• Dependências não resolvidas

DIAGNÓSTICO:
• Verificar structure de pastas
• Validar connection string
• Confirmar provider PostgreSQL
• Testar conectividade com banco

DEBUGGING:
• Adicionar logging temporário ao factory
• Verificar configuração carregada
• Testar criação de contexto manualmente
• Usar breakpoints durante migrations

SOLUÇÕES:
• Verificar appsettings.json no projeto API
• Confirmar PostgreSQL está rodando
• Validar permissões de banco de dados
• Atualizar packages EF Core

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO E COMANDOS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ESTRUTURA DE CONFIGURAÇÃO:
```json
// appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=AuthTenant_dev;Username=postgres;Password=password"
  }
}
```

COMANDOS TÍPICOS:
```bash
# Adicionar nova migração
dotnet ef migrations add AddNewFeature

# Aplicar migrações
dotnet ef database update

# Gerar script SQL
dotnet ef migrations script

# Verificar status do banco
dotnet ef database drop --dry-run

# Listar migrações
dotnet ef migrations list

# Remover última migração
dotnet ef migrations remove
```

WORKFLOW DE DESENVOLVIMENTO:
1. Modificar entidades no Domain
2. Adicionar/atualizar configurações
3. Criar migração: `dotnet ef migrations add <name>`
4. Revisar migração gerada
5. Aplicar ao banco: `dotnet ef database update`
6. Testar em ambiente local
7. Deployar migração para staging/production

VALIDAÇÃO:
```csharp
// Teste manual da factory
var factory = new ApplicationDbContextFactory();
var context = factory.CreateDbContext(new string[0]);
var canConnect = await context.Database.CanConnectAsync();
Console.WriteLine($"Can connect: {canConnect}");
```

INTEGRAÇÃO COM CI/CD:
• Executar migrações automaticamente
• Validar schema em pipelines
• Gerar scripts para deploy
• Backup antes de updates
• Rollback automático em falhas

BEST PRACTICES:
• Manter appsettings sincronizados
• Usar connection strings apropriadas por ambiente
• Testar migrações em ambiente isolado
• Documentar mudanças de schema
• Usar transações para operações complexas
