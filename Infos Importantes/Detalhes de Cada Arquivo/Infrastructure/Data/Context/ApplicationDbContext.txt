=================================
DOCUMENTAÇÃO TÉCNICA - ApplicationDbContext.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/Data/Context/ApplicationDbContext.cs
CATEGORIA: Database Context (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
ApplicationDbContext é o contexto principal do Entity Framework Core que serve
como ponte entre o domínio da aplicação e o banco de dados. Estende IdentityDbContext
para fornecer integração com ASP.NET Core Identity e implementa funcionalidades
avançadas de multi-tenancy, auditoria automática e isolamento de dados.

RESPONSABILIDADES:
• Gerenciar conexão e operações com banco de dados
• Implementar isolamento multi-tenant automático
• Fornecer auditoria automática de entidades
• Integrar com ASP.NET Core Identity
• Aplicar configurações de entidades via Fluent API
• Gerenciar query filters globais
• Trackear mudanças e aplicar regras de negócio

ARQUITETURA:
• DbContext Pattern (Entity Framework)
• Multi-Tenant Architecture
• Automatic Auditing Pattern
• Repository Pattern Foundation
• Identity Integration Pattern

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. ESTRUTURA TÉCNICA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

HERANÇA E IMPLEMENTAÇÃO:
• IdentityDbContext<ApplicationUser>: Base para ASP.NET Identity
• Implementa padrões de multi-tenancy
• Integra logging estruturado
• Gerencia ciclo de vida de entidades

DEPENDÊNCIAS INJETADAS:
• ICurrentTenantService: Resolução do tenant atual
• IHttpContextAccessor: Acesso ao contexto HTTP para auditoria
• ILogger<ApplicationDbContext>: Logging estruturado
• DbContextOptions<ApplicationDbContext>: Configurações do EF

DBSETS CONFIGURADOS:
• Users (ApplicationUser): Usuários do sistema via Identity
• Tenants: Entidades de tenant para multi-tenancy
• Products: Produtos isolados por tenant

MÉTODOS PRINCIPAIS:
• OnModelCreating(): Configuração do modelo de dados
• SaveChangesAsync(): Persistência com auditoria automática
• SetGlobalQuery<T>(): Aplicação de filtros globais
• EnsureDatabaseCreatedAsync(): Criação e migração de banco

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. MULTI-TENANCY E ISOLAMENTO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ESTRATÉGIA DE ISOLAMENTO:
• Query filters automáticos para entidades ITenantEntity
• TenantId aplicado automaticamente em entidades novas
• Resolução dinâmica do tenant atual via ICurrentTenantService
• Prevenção de cross-tenant data access

IMPLEMENTAÇÃO DE FILTROS:
• SetGlobalQuery<T>() aplica filtros usando reflection
• Expressões Lambda para filtros eficientes
• Aplicação automática a todas as entidades ITenantEntity
• Performance otimizada com query compilation

SEGURANÇA MULTI-TENANT:
• Validação obrigatória de TenantId em operações
• Exceções lançadas quando tenant não está definido
• Logs de segurança para operações de tenant
• Isolamento garantido a nível de banco de dados

CONTEXTO DE TENANT:
• Resolução automática via ICurrentTenantService
• Integração com middleware de tenant resolution
• Suporte a mudança dinâmica de contexto
• Validação de tenant válido antes de operações

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. AUDITORIA AUTOMÁTICA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

TRACKING DE MUDANÇAS:
• ChangeTracker monitora todas as alterações
• Aplicação automática de timestamps (CreatedAt, UpdatedAt)
• Identificação de usuário atual para auditoria
• Suporte a entidades IAuditableEntity

INFORMAÇÕES CAPTURADAS:
• CreatedAt: Timestamp UTC de criação
• UpdatedAt: Timestamp UTC da última modificação
• CreatedBy: ID do usuário que criou a entidade
• UpdatedBy: ID do usuário que modificou a entidade

RESOLUÇÃO DE USUÁRIO:
• GetCurrentUserId() via HttpContext
• Suporte a múltiplos claim types (NameIdentifier, sub, user_id)
• Fallback graceful quando usuário não disponível
• Logging de falhas na resolução de usuário

ESTADOS MONITORADOS:
• EntityState.Added: Entidades sendo criadas
• EntityState.Modified: Entidades sendo modificadas
• Aplicação seletiva baseada no estado da entidade

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. CONFIGURAÇÃO DE MODELO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

APLICAÇÃO DE CONFIGURAÇÕES:
• TenantConfiguration: Schema e constraints de tenants
• ApplicationUserConfiguration: Extensões de Identity
• ProductConfiguration: Estrutura de produtos
• Configurações aplicadas via Fluent API

MODULARIZAÇÃO:
• Configurations separadas por entidade
• Possibilidade de usar ApplyConfigurationsFromAssembly
• Organização limpa e manutenível
• Reutilização de configurações

ESTRUTURA DE SCHEMA:
• Tabelas bem definidas com constraints
• Índices otimizados para performance
• Relacionamentos com integridade referencial
• Suporte a tipos complexos e value objects

EXTENSIBILIDADE:
• Facilidade para adicionar novas entidades
• Configurações automáticas via convenções
• Override personalizado quando necessário
• Suporte a migrações automáticas

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. INTEGRAÇÃO COM ASP.NET IDENTITY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

HERANÇA DE IDENTITYDBCONTEXT:
• ApplicationUser como user entity customizada
• Todas as tabelas de Identity configuradas automaticamente
• Suporte completo a roles, claims, tokens
• Extensibilidade mantida

TABELAS DE IDENTITY:
• AspNetUsers: Usuários com campos customizados
• AspNetRoles: Roles do sistema
• AspNetUserRoles: Associação usuário-role
• AspNetUserClaims: Claims personalizados
• AspNetUserLogins: Logins externos
• AspNetUserTokens: Tokens de segurança

MULTI-TENANCY + IDENTITY:
• ApplicationUser estendido com TenantId
• Isolamento de usuários por tenant
• Roles podem ser compartilhadas ou isoladas
• Claims incluem informações de tenant

FUNCIONALIDADES MANTIDAS:
• UserManager<ApplicationUser> funcional
• SignInManager<ApplicationUser> operacional
• RoleManager<IdentityRole> disponível
• Todos os serviços de Identity integrados

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. LOGGING E MONITORAMENTO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

LOGGING ESTRUTURADO:
• ILogger<ApplicationDbContext> injetado
• Logs de debug para operações de configuração
• Logs de erro para falhas de operação
• Logs de warning para situações anômalas

EVENTOS MONITORADOS:
• Configuração de modelo completada
• Aplicação de tenant a entidades
• Falhas na resolução de usuário
• Operações de save com contagem de entidades

NÍVEIS DE LOG:
• Debug: Informações detalhadas de desenvolvimento
• Information: Eventos importantes do sistema
• Warning: Situações que merecem atenção
• Error: Falhas que impedem operações

ESTRUTURA DE LOGS:
• Mensagens padronizadas e consistentes
• Parâmetros estruturados para análise
• Context information incluída
• Performance tracking implícito

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. PERFORMANCE E OTIMIZAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

QUERY OPTIMIZATION:
• Global query filters aplicados automaticamente
• DbSet como properties para lazy loading
• Configurações otimizadas por entidade
• Índices estratégicos via configurações

CHANGE TRACKING:
• Tracking eficiente de mudanças
• Aplicação seletiva de auditoria
• Minimização de roundtrips ao banco
• Batching automático de operações

CONEXÃO E RECURSOS:
• DbContext com lifecycle gerenciado
• Connection pooling via DI container
• Async operations para não-blocking
• Proper disposal de recursos

RECOMENDAÇÕES:
• Use AsNoTracking() para queries read-only
• Implemente paginação para grandes resultsets
• Consider bulk operations para grandes volumes
• Monitor query execution plans

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. TRATAMENTO DE ERROS E ROBUSTEZ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

VALIDAÇÕES DE ENTRADA:
• ArgumentNullException para parâmetros obrigatórios
• Validação de tenant context antes de operações
• Verificação de estado consistente

EXCEPTION HANDLING:
• Try-catch em operações críticas
• Logging de exceções antes de re-throw
• Mensagens de erro claras e acionáveis
• Preservação de stack trace

OPERAÇÕES TRANSACIONAIS:
• SaveChangesAsync em transação implícita
• Rollback automático em caso de erro
• Consistency garantida por Entity Framework
• Isolation levels apropriados

RECUPERAÇÃO DE FALHAS:
• Logs detalhados para debugging
• Informações de contexto preservadas
• Estado do sistema mantido consistente
• Graceful degradation quando possível

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO E CONFIGURAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONFIGURAÇÃO NO STARTUP:
```csharp
services.AddDbContext<ApplicationDbContext>(options =>
{
    options.UseNpgsql(connectionString);
    options.EnableSensitiveDataLogging(isDevelopment);
    options.EnableDetailedErrors(isDevelopment);
});

services.AddScoped<ICurrentTenantService, CurrentTenantService>();
services.AddHttpContextAccessor();
```

USO EM REPOSITÓRIO:
```csharp
public class ProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;
    
    public ProductRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<IEnumerable<Product>> GetAllAsync()
    {
        // Query filter aplicado automaticamente
        return await _context.Products
            .Where(p => p.IsActive)
            .OrderBy(p => p.Name)
            .ToListAsync();
    }
    
    public async Task<Product> CreateAsync(Product product)
    {
        _context.Products.Add(product);
        // TenantId e auditoria aplicados automaticamente
        await _context.SaveChangesAsync();
        return product;
    }
}
```

DESIGN-TIME FACTORY:
```csharp
// Usado para migrações e ferramentas EF
public class ApplicationDbContextFactory : IDesignTimeDbContextFactory<ApplicationDbContext>
{
    public ApplicationDbContext CreateDbContext(string[] args)
    {
        // Implementação com serviços mock para design-time
    }
}
```

MIGRAÇÕES:
```bash
# Adicionar migração
dotnet ef migrations add InitialCreate

# Aplicar migrações
dotnet ef database update

# Verificar pending migrations
dotnet ef migrations list
```

BEST PRACTICES:
• Sempre configure TenantService antes de usar
• Use HttpContextAccessor para auditoria
• Configure logging apropriado
• Monitore performance de queries
• Teste isolamento multi-tenant
• Valide migrações em ambiente staging
