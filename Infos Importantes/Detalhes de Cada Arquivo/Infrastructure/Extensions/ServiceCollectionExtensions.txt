=================================
DOCUMENTAÇÃO TÉCNICA - ServiceCollectionExtensions.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/Extensions/ServiceCollectionExtensions.cs
CATEGORIA: Dependency Injection Extension (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
ServiceCollectionExtensions fornece métodos de extensão para IServiceCollection,
centralizando a configuração de todas as dependências da camada Infrastructure.
Implementa o padrão Extension Methods para uma API limpa de configuração de DI,
com suporte a múltiplos cenários (produção, desenvolvimento, testes).

RESPONSABILIDADES:
• Registrar serviços de infraestrutura no container DI
• Configurar Entity Framework DbContext
• Configurar serviços multi-tenant
• Registrar repositórios e padrões de acesso a dados
• Configurar cross-cutting concerns (cache, logging)
• Fornecer overloads para diferentes cenários
• Validar configuração de serviços

ARQUITETURA:
• Extension Methods Pattern
• Service Locator Pattern
• Dependency Injection Configuration
• Environment-Specific Configuration
• Modular Service Registration

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. ESTRUTURA TÉCNICA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

MÉTODOS PRINCIPAIS:
• AddInfrastructure(services, configuration): Configuração completa
• AddInfrastructureWithoutDatabase(services): Configuração sem banco
• AddInfrastructure(services, configureDb): Configuração customizada
• AddInfrastructureForTesting(services, dbName): Configuração para testes
• ValidateInfrastructureConfiguration(services): Validação de config

MÉTODOS PRIVADOS DE CONFIGURAÇÃO:
• AddDatabaseServices(): Configuração de Entity Framework
• AddMultiTenantServices(): Serviços de multi-tenancy
• AddRepositoryServices(): Repositórios e padrões de dados
• AddCrossCuttingServices(): Concerns transversais

CLASSES AUXILIARES:
• TestHttpContextAccessor: Mock para testes

VALIDAÇÕES:
• ArgumentNullException para parâmetros obrigatórios
• Validação de connection string
• Verificação de serviços registrados

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. CONFIGURAÇÃO DE BANCO DE DADOS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONFIGURAÇÃO POSTGRESQL:
• UseNpgsql() com connection string "DefaultConnection"
• MigrationsAssembly configurado para "AuthTenant.Infrastructure"
• EnableRetryOnFailure() para resiliência
• Configurações específicas por ambiente

CONFIGURAÇÕES DE DESENVOLVIMENTO:
• EnableSensitiveDataLogging() para debug
• EnableDetailedErrors() para informações detalhadas
• LogTo(Console.WriteLine) para logging de queries
• Configurações habilitadas apenas em Development

CONFIGURAÇÕES DE PERFORMANCE:
• EnableServiceProviderCaching() para cache de providers
• Connection pooling automático via Entity Framework
• Retry policies para falhas temporárias
• Configurações otimizadas para produção

HEALTH CHECKS:
• Suporte a AddDbContextCheck() (requer package adicional)
• Monitoring de saúde do banco de dados
• Tags para categorização de health checks
• Integration com sistemas de monitoramento

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. SERVIÇOS MULTI-TENANT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

RESOLUÇÃO DE TENANT:
• IHttpContextAccessor para acesso ao contexto HTTP
• ICurrentTenantService para resolução do tenant atual
• ITenantRepository para operações de tenant
• MemoryCache para cache de informações de tenant

ISOLATION STRATEGY:
• Tenant ID como partition key
• Query filters automáticos via ApplicationDbContext
• Isolamento transparente em todas as operações
• Segurança garantida a nível de infraestrutura

PERFORMANCE OPTIMIZATION:
• Cache em memória para informações de tenant
• Resolução eficiente via middleware
• Mínimo overhead por request
• Estratégias de cache configuráveis

EXTENSIBILIDADE:
• Support para múltiplas estratégias de isolamento
• Configuração flexível de tenant resolution
• Integration com providers externos
• Support para tenant-specific configurations

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. REPOSITÓRIOS E PADRÕES DE DADOS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

REPOSITORY PATTERN:
• IRepository<T> como interface base genérica
• BaseRepository<T> como implementação base
• IProductRepository como repositório específico
• ITenantRepository para operações de tenant

REGISTRATION STRATEGY:
• Scoped lifetime para repositórios
• Generic repository registration
• Specific repository implementations
• Support para Unit of Work pattern

DECORATOR PATTERNS (COMMENTED):
• CachedProductRepository para cache
• LoggingProductRepository para auditoria
• Performance monitoring decorators
• Security validation decorators

TESTING SUPPORT:
• AddRepositoryServicesWithoutDatabase() para testes
• Mock implementations facilmente injetáveis
• Isolation entre testes
• In-memory database support (quando package disponível)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. CROSS-CUTTING CONCERNS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CACHING STRATEGY:
• AddMemoryCache() como padrão
• Support para Redis (requer package adicional)
• Configuração flexível de cache providers
• Cache policies configuráveis

BACKGROUND SERVICES:
• Support para Hosted Services
• TenantCacheRefreshService (example)
• Background processing capabilities
• Scheduled tasks integration

MONITORING E OBSERVABILITY:
• Application Insights integration (commented)
• Custom telemetry services
• Performance monitoring
• Health checks integration

CUSTOM SERVICES:
• IEmailService para notificações
• IAuditService para auditoria
• Service interfaces prontas para implementação
• Extensibility points bem definidos

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. MÚLTIPLOS CENÁRIOS DE CONFIGURAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PRODUÇÃO:
• AddInfrastructure(services, configuration)
• Configuração completa com banco real
• Connection string via configuration
• Performance e security otimizadas

DESENVOLVIMENTO:
• Mesma configuração de produção
• Logging detalhado habilitado
• Sensitive data logging para debug
• Connection string local

TESTES:
• AddInfrastructureForTesting()
• In-memory database (quando disponível)
• Mocks para serviços externos
• Isolation entre test cases

CUSTOM SCENARIOS:
• AddInfrastructure(services, configureDb)
• Custom database configuration
• Provider-specific optimizations
• Environment-specific settings

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. VALIDAÇÃO E DEBUGGING
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

VALIDAÇÃO AUTOMÁTICA:
• ValidateInfrastructureConfiguration() para verificação
• Checking de serviços obrigatórios
• Validation durante startup em Development
• Early detection de configuração incorreta

REQUIRED SERVICES:
• ApplicationDbContext
• ICurrentTenantService
• ITenantRepository
• IProductRepository
• IRepository<>
• IHttpContextAccessor

DEBUGGING SUPPORT:
• Console output para serviços faltantes
• Exception handling durante validation
• Clear error messages
• Development-time diagnostics

ERROR HANDLING:
• ArgumentNullException para parâmetros obrigatórios
• InvalidOperationException para configuração inválida
• Graceful handling de missing services
• Clear error messages com context

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. EXTENSIBILIDADE E FUTURAS MELHORIAS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PACKAGE DEPENDENCIES (COMMENTED):
• Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore
• Microsoft.Extensions.Caching.StackExchangeRedis
• Microsoft.EntityFrameworkCore.InMemory
• Microsoft.ApplicationInsights.AspNetCore

DECORATOR PATTERNS:
• Repository decorators para cross-cutting concerns
• Caching, logging, security decorators
• Performance monitoring decorators
• Easy to add via services.Decorate<>()

CONFIGURATION EXTENSIONS:
• Environment-specific configurations
• Feature flags integration
• Cloud provider integrations
• Configuration validation

MONITORING INTEGRATION:
• Application Insights telemetry
• Custom metrics collection
• Performance monitoring
• Health checks dashboard

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CONFIGURAÇÃO NO PROGRAM.CS:
```csharp
// Program.cs - Configuração principal
var builder = WebApplication.CreateBuilder(args);

// Adicionar serviços de infraestrutura
builder.Services.AddInfrastructure(builder.Configuration);

var app = builder.Build();

// Validar configuração em Development
if (app.Environment.IsDevelopment())
{
    var isValid = app.Services.ValidateInfrastructureConfiguration();
    if (!isValid)
    {
        throw new InvalidOperationException("Infrastructure configuration is invalid");
    }
}
```

CONFIGURAÇÃO CUSTOMIZADA:
```csharp
// Configuração com opções customizadas
builder.Services.AddInfrastructure(options =>
{
    options.UseNpgsql(connectionString, npgsqlOptions =>
    {
        npgsqlOptions.MigrationsAssembly("AuthTenant.Infrastructure");
        npgsqlOptions.CommandTimeout(30);
    });
    
    options.EnableRetryOnFailure(maxRetryCount: 5);
});
```

CONFIGURAÇÃO PARA TESTES:
```csharp
// TestStartup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddInfrastructureForTesting("TestDatabase");
    
    // Override serviços específicos para teste
    services.AddSingleton<ICurrentTenantService, MockTenantService>();
}
```

CONFIGURAÇÃO SEM BANCO:
```csharp
// Para cenários onde banco é configurado externamente
services.AddInfrastructureWithoutDatabase();

// Configurar banco separadamente
services.AddDbContext<ApplicationDbContext>(options =>
{
    options.UseCustomProvider(customConnectionString);
});
```

USO EM CONTROLLERS:
```csharp
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repository;
    private readonly ICurrentTenantService _tenantService;
    
    public ProductsController(
        IProductRepository repository,
        ICurrentTenantService tenantService)
    {
        _repository = repository;
        _tenantService = tenantService;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetProducts()
    {
        // Tenant isolation aplicado automaticamente
        var products = await _repository.GetAllAsync();
        return Ok(products);
    }
}
```

BEST PRACTICES:
• Sempre usar a configuração completa em produção
• Validar configuração durante startup em Development
• Usar configuração de teste em unit tests
• Configurar health checks para monitoramento
• Implementar cache strategies apropriadas
• Monitor performance de repositórios
• Usar connection string seguras
• Implement proper error handling
