=================================
DOCUMENTAÇÃO TÉCNICA - CurrentTenantService.cs
=================================

ARQUIVO: AuthTenant.Infrastructure/MultiTenant/CurrentTenantService.cs
CATEGORIA: Multi-Tenancy Service (Infrastructure)
ÚLTIMA ATUALIZAÇÃO: ${DateTime.Now}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. VISÃO GERAL
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DESCRIÇÃO:
CurrentTenantService é o serviço central responsável por resolver e gerenciar 
o contexto do tenant atual em uma arquitetura multi-tenant. Implementa múltiplas 
estratégias de resolução de tenant com fallback automático e cache para otimização 
de performance.

RESPONSABILIDADES:
• Resolver tenant ID através de múltiplas fontes (JWT, headers, override)
• Implementar cache em memória para otimização de performance
• Gerenciar override manual de tenant (útil para testes)
• Integrar com repositório de tenant para validação
• Fornecer logging e auditoria completos
• Garantir thread-safety e error handling robusto

ARQUITETURA:
• Service Pattern com injeção de dependência
• Multiple Resolution Strategy Pattern
• Caching Strategy Pattern
• Repository Pattern Integration
• Comprehensive Logging Pattern

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2. ESTRATÉGIAS DE RESOLUÇÃO DE TENANT
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ORDEM DE PRIORIDADE:
1. Override Manual (_tenantIdOverride)
2. JWT Claims (TenantConstants.TenantIdClaimType)  
3. HTTP Headers (TenantConstants.TenantIdHeaderName)
4. Default Tenant (TenantConstants.DefaultTenantId)

ESTRATÉGIA 1 - OVERRIDE MANUAL:
• Usado principalmente para testes e cenários específicos
• Permite definir tenant programaticamente
• Tem prioridade máxima sobre outras estratégias
• Inclui método ClearTenantOverride() para limpeza

ESTRATÉGIA 2 - JWT CLAIMS:
• Método mais seguro, baseado em token autenticado
• Extrai tenant do claim específico no JWT
• Valida se usuário está autenticado
• Sanitiza e valida o valor do claim

ESTRATÉGIA 3 - HTTP HEADERS:
• Fallback para cenários onde JWT não está disponível
• Extrai tenant do header HTTP específico
• Sanitiza entrada para prevenir ataques
• Usado em APIs, integrações e cenários especiais

ESTRATÉGIA 4 - DEFAULT TENANT:
• Último fallback quando nenhuma fonte está disponível
• Garante que sempre existe um tenant válido
• Usado para operações que não requerem tenant específico

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3. CACHE E PERFORMANCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ESTRATÉGIA DE CACHE:
• IMemoryCache para cache em memória
• Cache duration: 15 minutos (CacheDuration)
• Cache key: "tenant_{tenantId}"
• Invalidação automática em SetTenant()

BENEFÍCIOS DO CACHE:
• Reduz calls para o banco de dados
• Melhora performance de resolução de tenant
• Reduz latência em aplicações multi-tenant
• Escala melhor com múltiplos tenants

CACHE INVALIDATION:
• Manual via ClearTenantOverride()
• Automática quando SetTenant() é chamado
• Cache expira automaticamente após 15 minutos
• Permite refresh de dados de tenant sem restart

CACHE MISS HANDLING:
• Busca no repositório quando não está em cache
• Armazena resultado no cache para próximas consultas
• Log detalhado para cache hits/misses
• Error handling para falhas de repositório

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4. SEGURANÇA E VALIDAÇÃO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

VALIDAÇÃO DE ENTRADA:
• ArgumentNullException para dependências obrigatórias
• Sanitização de strings de tenant ID
• Validação de formato e comprimento
• Prevenção de injection attacks

VALIDAÇÃO DE JWT:
• Verifica se usuário está autenticado (IsAuthenticated)
• Valida existência e formato do claim
• Sanitiza valor do claim antes de usar
• Proteção contra tokens maliciosos

VALIDAÇÃO DE HEADERS:
• Sanitização de headers HTTP
• Trim de whitespace
• Validação de formato
• Proteção contra header injection

ERROR HANDLING:
• Try-catch em todas as operações críticas
• Fallback para default tenant em caso de erro
• Logging detalhado de todas as exceções
• Graceful degradation em cenários de falha

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5. LOGGING E AUDITORIA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

NÍVEIS DE LOG:
• LogDebug: Resolução de tenant bem-sucedida
• LogInformation: Override manual de tenant
• LogWarning: Tenant não encontrado, HttpContext ausente
• LogError: Exceções durante resolução

AUDITORIA DE OPERAÇÕES:
• Todas as mudanças de tenant são logadas
• Rastreamento de origem da resolução
• Timestamps para todas as operações
• Correlação de logs por request

LOG ESTRUTURADO:
• Parâmetros estruturados para fácil busca
• Correlation IDs para rastreamento
• Performance metrics (cache hits/misses)
• Security events (tentativas de acesso)

DEBUGGING SUPPORT:
• Logs detalhados em Development
• Informações de contexto em cada log
• Stack traces para exceções
• Cache statistics

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6. INTEGRAÇÃO COM REPOSITÓRIO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

REPOSITORY DEPENDENCY:
• ITenantRepository para operações de dados
• GetByIdAsync() para buscar tenant completo
• CancellationToken support para cancelamento
• Async/await para operações não-bloqueantes

TENANT VALIDATION:
• Verifica existência do tenant no banco
• Valida se tenant está ativo (IsActive)
• Cache do resultado para performance
• Error handling para falhas de repositório

MÉTODO GetCurrentTenantAsync():
• Retorna objeto Tenant completo
• Implementa cache transparente
• Async para não bloquear thread
• Null-safe com tratamento adequado

MÉTODO IsCurrentTenantActiveAsync():
• Verifica se tenant atual está ativo
• Usa GetCurrentTenantAsync() internamente
• Retorna boolean para fácil uso
• Performance otimizada via cache

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
7. THREAD SAFETY E CONCORRÊNCIA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

THREAD SAFETY:
• IMemoryCache é thread-safe por natureza
• HttpContextAccessor é thread-safe
• Operações atômicas para override
• Readonly fields onde possível

SCOPED LIFETIME:
• Registrado como Scoped no DI container
• Uma instância por request HTTP
• Não compartilha estado entre requests
• Garbage collection automático

ASYNC OPERATIONS:
• ConfigureAwait(false) onde apropriado
• CancellationToken support
• Async/await patterns corretos
• Deadlock prevention

CONCURRENCY HANDLING:
• Multiple requests podem resolver tenant simultaneamente
• Cache é consistente entre threads
• No shared mutable state
• Exception isolation entre requests

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8. MÉTODOS AUXILIARES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ExtractTenantFromClaims():
• Static method para extração de claims
• Valida autenticação antes de extrair
• Sanitiza e valida o valor do claim
• Null-safe com validação de whitespace

ExtractTenantFromHeaders():
• Static method para extração de headers
• Header dictionary safe access
• Trim de whitespace automático
• Validation de formato

SetTenant():
• Override manual de tenant
• Clear cache quando necessário
• Logging de mudanças
• Usado principalmente em testes

ClearTenantOverride():
• Remove override manual
• Restore comportamento padrão
• Log da operação
• Útil para cleanup após testes

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
9. CONFIGURAÇÃO E DEPENDÊNCIAS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

DEPENDÊNCIAS INJETADAS:
• IHttpContextAccessor: Acesso ao contexto HTTP
• IMemoryCache: Cache em memória para performance
• ILogger<CurrentTenantService>: Logging estruturado
• ITenantRepository: Operações de dados de tenant

CONFIGURAÇÃO NO DI:
```csharp
services.AddScoped<ICurrentTenantService, CurrentTenantService>();
services.AddHttpContextAccessor();
services.AddMemoryCache();
services.AddScoped<ITenantRepository, TenantRepository>();
```

CONFIGURAÇÃO DE CACHE:
• Cache duration: 15 minutos (configurável)
• Memory cache com LRU eviction
• Automatic cleanup de entries expiradas
• Configurável via appsettings se necessário

CONSTANTS DEPENDENCY:
• TenantConstants.TenantIdClaimType
• TenantConstants.TenantIdHeaderName  
• TenantConstants.DefaultTenantId
• Centralizadas em AuthTenant.Shared

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
10. EXEMPLO DE USO
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

USO EM CONTROLLERS:
```csharp
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly ICurrentTenantService _tenantService;
    
    public ProductsController(ICurrentTenantService tenantService)
    {
        _tenantService = tenantService;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetProducts()
    {
        // Resolver tenant automaticamente
        var tenantId = _tenantService.TenantId;
        
        // Verificar se tenant é válido
        if (!_tenantService.HasValidTenant)
        {
            return BadRequest("Invalid tenant");
        }
        
        // Obter objeto tenant completo
        var tenant = await _tenantService.GetCurrentTenantAsync();
        if (tenant == null)
        {
            return NotFound("Tenant not found");
        }
        
        // Verificar se tenant está ativo
        var isActive = await _tenantService.IsCurrentTenantActiveAsync();
        if (!isActive)
        {
            return Forbid("Tenant is inactive");
        }
        
        // Usar tenant context...
        return Ok($"Products for tenant: {tenantId}");
    }
}
```

USO EM TESTES:
```csharp
[Test]
public async Task Should_Return_Products_For_Specific_Tenant()
{
    // Arrange
    var tenantService = serviceProvider.GetService<ICurrentTenantService>();
    tenantService.SetTenant("test-tenant-123");
    
    // Act
    var products = await productService.GetProductsAsync();
    
    // Assert
    Assert.AreEqual("test-tenant-123", tenantService.TenantId);
    Assert.IsTrue(products.All(p => p.TenantId == "test-tenant-123"));
    
    // Cleanup
    tenantService.ClearTenantOverride();
}
```

USO EM SERVICES:
```csharp
public class ProductService
{
    private readonly ICurrentTenantService _tenantService;
    private readonly IProductRepository _repository;
    
    public async Task<List<Product>> GetProductsAsync()
    {
        var tenantId = _tenantService.TenantId;
        
        // Repository automaticamente filtra por tenant
        return await _repository.GetAllAsync();
    }
    
    public async Task<Product> CreateProductAsync(Product product)
    {
        var tenant = await _tenantService.GetCurrentTenantAsync();
        if (tenant == null || !tenant.IsActive)
        {
            throw new InvalidOperationException("Invalid tenant context");
        }
        
        product.TenantId = tenant.Id;
        return await _repository.CreateAsync(product);
    }
}
```

CONFIGURAÇÃO JWT:
```csharp
// No Program.cs para incluir tenant no token
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        // Configuração JWT...
        options.Events = new JwtBearerEvents
        {
            OnTokenValidated = context =>
            {
                var tenantService = context.HttpContext.RequestServices
                    .GetRequiredService<ICurrentTenantService>();
                
                // Tenant será resolvido automaticamente via claims
                var tenantId = tenantService.TenantId;
                
                return Task.CompletedTask;
            }
        };
    });
```

BEST PRACTICES:
• Sempre verificar HasValidTenant antes de operações críticas
• Usar IsCurrentTenantActiveAsync() para validar tenant ativo
• Implementar retry logic para falhas de repositório
• Cache de tenant data para melhor performance
• Logging detalhado para auditoria e debugging
• Testes unitários para todas as estratégias de resolução
• Clear overrides após testes para evitar state pollution
• Monitor cache hit ratios para otimização
