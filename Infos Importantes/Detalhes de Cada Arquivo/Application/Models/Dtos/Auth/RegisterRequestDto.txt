# RegisterRequestDto.cs - DTO de Requisi√ß√£o de Registro

## üìã Vis√£o Geral
DTO abrangente para requisi√ß√µes de registro de usu√°rio em ambiente multi-tenant. Implementa valida√ß√µes rigorosas, verifica√ß√µes de seguran√ßa, compliance regulat√≥rio e suporte a auditoria completa para garantir registro seguro e em conformidade.

## üèóÔ∏è Arquitetura e Estrutura

### Classe Selada
```csharp
public sealed class RegisterRequestDto
```
- **Sealed**: Previne heran√ßa para manter controle total
- **Comprehensive Validation**: Valida√ß√µes abrangentes para registro
- **Multi-Tenant Ready**: Suporte nativo √† arquitetura multi-tenant
- **Compliance Focused**: Foco em conformidade regulat√≥ria

## üîê Informa√ß√µes de Autentica√ß√£o

### Email do Usu√°rio
```csharp
[Required(ErrorMessage = "Email address is required")]
[EmailAddress(ErrorMessage = "Please provide a valid email address")]
[StringLength(256, ErrorMessage = "Email address cannot exceed 256 characters")]
[JsonPropertyName("email")]
public string Email { get; set; } = string.Empty;
```
- **Primary Identifier**: Identificador √∫nico dentro do tenant
- **RFC Compliant**: Valida√ß√£o segundo padr√µes RFC
- **Case Insensitive**: Processado em lowercase normalizado
- **Uniqueness**: Deve ser √∫nico no escopo do tenant

### Sistema de Senhas
```csharp
[Required(ErrorMessage = "Password is required")]
[StringLength(128, MinimumLength = 8, ErrorMessage = "Password must be between 8 and 128 characters")]
[DataType(DataType.Password)]
[JsonPropertyName("password")]
public string Password { get; set; } = string.Empty;

[Required(ErrorMessage = "Password confirmation is required")]
[DataType(DataType.Password)]
[Compare(nameof(Password), ErrorMessage = "Password and confirmation do not match")]
[JsonPropertyName("confirmPassword")]
public string ConfirmPassword { get; set; } = string.Empty;
```
- **Strength Requirements**: Valida√ß√£o de for√ßa da senha
- **Confirmation**: Confirma√ß√£o obrigat√≥ria para prevenir erros
- **Security**: Nunca armazenadas em plain text
- **Complexity**: Verifica√ß√£o de complexidade implementada

## üë§ Informa√ß√µes Pessoais

### Dados Nominais
```csharp
[Required(ErrorMessage = "First name is required")]
[StringLength(50, MinimumLength = 1, ErrorMessage = "First name must be between 1 and 50 characters")]
[RegularExpression(@"^[a-zA-Z√Ä-√ø\s\-'\.]+$", ErrorMessage = "First name contains invalid characters")]
[JsonPropertyName("firstName")]
public string FirstName { get; set; } = string.Empty;

[Required(ErrorMessage = "Last name is required")]
[StringLength(50, MinimumLength = 1, ErrorMessage = "Last name must be between 1 and 50 characters")]
[RegularExpression(@"^[a-zA-Z√Ä-√ø\s\-'\.]+$", ErrorMessage = "Last name contains invalid characters")]
[JsonPropertyName("lastName")]
public string LastName { get; set; } = string.Empty;
```
- **Character Validation**: Apenas caracteres v√°lidos para nomes
- **Unicode Support**: Suporte a caracteres acentuados
- **Length Limits**: Limites apropriados para nomes
- **Special Characters**: Permite h√≠fens, apostrofes e pontos

### Identifica√ß√£o do Tenant
```csharp
[Required(ErrorMessage = "Tenant ID is required")]
[StringLength(50, MinimumLength = 1, ErrorMessage = "Tenant ID must be between 1 and 50 characters")]
[JsonPropertyName("tenantId")]
public string TenantId { get; set; } = string.Empty;
```
- **Multi-Tenancy**: Essencial para isolamento de dados
- **Validation**: Formato validado para seguran√ßa
- **Organization**: Define a organiza√ß√£o do usu√°rio

## üìû Informa√ß√µes de Contato Opcionais

### Telefone
```csharp
[Phone(ErrorMessage = "Please provide a valid phone number")]
[StringLength(20)]
[JsonPropertyName("phoneNumber")]
public string? PhoneNumber { get; set; }
```
- **Optional**: Campo opcional para verifica√ß√£o adicional
- **Format Validation**: Valida√ß√£o de formato de telefone
- **2FA Ready**: Preparado para autentica√ß√£o de dois fatores

## üåê Prefer√™ncias de Localiza√ß√£o

### Idioma e Timezone
```csharp
[StringLength(10)]
[JsonPropertyName("preferredLanguage")]
public string? PreferredLanguage { get; set; } = "en-US";

[StringLength(50)]
[JsonPropertyName("timezone")]
public string? Timezone { get; set; }
```
- **Localization**: Suporte √† localiza√ß√£o
- **User Experience**: Melhora experi√™ncia do usu√°rio
- **Default Values**: Valores padr√£o apropriados

## ‚öñÔ∏è Compliance e Termos

### Aceita√ß√£o de Termos
```csharp
[Range(typeof(bool), "true", "true", ErrorMessage = "You must accept the terms of service")]
[JsonPropertyName("acceptTerms")]
public bool AcceptTerms { get; set; } = false;
```
- **Legal Requirement**: Obrigat√≥rio para compliance
- **Audit Trail**: Rastreado para fins legais
- **Validation**: Deve ser explicitamente true

### Prefer√™ncias de Marketing
```csharp
[JsonPropertyName("marketingOptIn")]
public bool MarketingOptIn { get; set; } = false;
```
- **GDPR Compliant**: Opt-in expl√≠cito para marketing
- **Privacy**: Respeita privacidade do usu√°rio
- **Default**: Padr√£o false para prote√ß√£o

## üìä Analytics e Tracking

### Fonte de Registro
```csharp
[StringLength(50)]
[JsonPropertyName("registrationSource")]
public string? RegistrationSource { get; set; }
```
- **Analytics**: Tracking de origem dos usu√°rios
- **Marketing**: An√°lise de efetividade de campanhas
- **Optional**: N√£o obrigat√≥rio para funcionamento

### Metadados Extens√≠veis
```csharp
[JsonPropertyName("metadata")]
public IDictionary<string, string>? Metadata { get; set; }
```
- **Flexible**: Dados adicionais conforme necess√°rio
- **Tracking**: C√≥digos de refer√™ncia, campanhas, etc.
- **Extensible**: Preparado para futuras necessidades

## üß† Propriedades Computadas

### Email Normalizado
```csharp
[JsonIgnore]
public string NormalizedEmail => Email.Trim().ToLowerInvariant();
```
- **Database Consistency**: Busca consistente no banco
- **Case Insensitive**: Remove diferen√ßas de capitaliza√ß√£o
- **Whitespace**: Remove espa√ßos desnecess√°rios

### Nome Completo
```csharp
[JsonIgnore]
public string FullName => $"{FirstName.Trim()} {LastName.Trim()}".Trim();
```
- **Display Purpose**: Para exibi√ß√£o na interface
- **Formatting**: Formata√ß√£o consistente
- **Trimmed**: Remove espa√ßos extras

### For√ßa da Senha
```csharp
[JsonIgnore]
public bool HasStrongPassword => IsStrongPassword(Password);
```
- **Security Assessment**: Avalia√ß√£o de seguran√ßa
- **Complexity Check**: Verifica√ß√£o de complexidade
- **Real-time**: Pode ser usado para feedback em tempo real

## ‚úÖ Sistema de Valida√ß√£o Avan√ßado

### Valida√ß√£o Completa
```csharp
public bool IsValid()
{
    return !string.IsNullOrWhiteSpace(Email) &&
           !string.IsNullOrWhiteSpace(Password) &&
           !string.IsNullOrWhiteSpace(FirstName) &&
           !string.IsNullOrWhiteSpace(LastName) &&
           !string.IsNullOrWhiteSpace(TenantId) &&
           Password == ConfirmPassword &&
           AcceptTerms &&
           IsValidEmail(Email) &&
           IsStrongPassword(Password) &&
           IsValidName(FirstName) &&
           IsValidName(LastName) &&
           IsValidTenantId(TenantId);
}
```
- **Comprehensive**: Valida√ß√£o completa de todos os campos
- **Business Rules**: Aplica regras de neg√≥cio espec√≠ficas
- **Security**: Verifica requisitos de seguran√ßa

### Valida√ß√£o de Email Avan√ßada
```csharp
private static bool IsValidEmail(string email)
{
    if (string.IsNullOrWhiteSpace(email) || email.Length > 256)
        return false;

    try
    {
        var addr = new System.Net.Mail.MailAddress(email);
        return addr.Address == email && !email.Contains("..");
    }
    catch
    {
        return false;
    }
}
```
- **Double Dot Check**: Previne emails com pontos duplos
- **Framework Validation**: Usa valida√ß√£o do .NET
- **Exception Safe**: N√£o propaga exce√ß√µes

### Valida√ß√£o de Senha Forte
```csharp
private static bool IsStrongPassword(string password)
{
    if (string.IsNullOrWhiteSpace(password) || password.Length < 8 || password.Length > 128)
        return false;

    // Check for at least 3 of 4 character types
    var hasLower = password.Any(char.IsLower);
    var hasUpper = password.Any(char.IsUpper);
    var hasDigit = password.Any(char.IsDigit);
    var hasSpecial = password.Any(c => !char.IsLetterOrDigit(c));

    var complexityScore = (hasLower ? 1 : 0) + (hasUpper ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSpecial ? 1 : 0);
    
    return complexityScore >= 3 && !IsCommonPassword(password);
}
```
- **Character Diversity**: Requer 3 de 4 tipos de caracteres
- **Common Password Check**: Previne senhas comuns
- **Complexity Score**: Sistema de pontua√ß√£o de complexidade

### Valida√ß√£o de Senhas Comuns
```csharp
private static bool IsCommonPassword(string password)
{
    var commonPasswords = new[]
    {
        "password", "123456", "12345678", "qwerty", "abc123",
        "password123", "admin", "letmein", "welcome", "monkey"
    };

    return commonPasswords.Contains(password.ToLowerInvariant());
}
```
- **Security**: Previne uso de senhas fracas conhecidas
- **Dictionary Attack**: Prote√ß√£o contra dicion√°rios
- **Extensible**: Lista pode ser expandida

### Valida√ß√£o de Nomes
```csharp
private static bool IsValidName(string name)
{
    if (string.IsNullOrWhiteSpace(name) || name.Length > 50)
        return false;

    // Allow letters, spaces, hyphens, apostrophes, and periods
    return Regex.IsMatch(name, @"^[a-zA-Z√Ä-√ø\s\-'\.]+$");
}
```
- **Unicode Support**: Suporte a caracteres acentuados
- **Cultural Sensitivity**: Permite nomes de diferentes culturas
- **Special Characters**: Apostrofes, h√≠fens e pontos permitidos

## üìã Logging e Auditoria Segura

### Informa√ß√µes Seguras para Log
```csharp
public IDictionary<string, object> GetLoggingInfo()
{
    return new Dictionary<string, object>
    {
        ["email"] = Email.Length > 0 ? $"{Email[0]}***@{Email.Split('@').LastOrDefault()}" : "unknown",
        ["firstName"] = FirstName.Length > 0 ? $"{FirstName[0]}***" : "unknown",
        ["lastName"] = LastName.Length > 0 ? $"{LastName[0]}***" : "unknown",
        ["tenantId"] = TenantId,
        ["hasPhoneNumber"] = !string.IsNullOrWhiteSpace(PhoneNumber),
        ["preferredLanguage"] = PreferredLanguage ?? "not-specified",
        ["acceptTerms"] = AcceptTerms,
        ["marketingOptIn"] = MarketingOptIn,
        ["registrationSource"] = RegistrationSource ?? "unknown",
        ["hasStrongPassword"] = HasStrongPassword,
        ["timestamp"] = DateTime.UtcNow
    };
}
```
- **Privacy Protection**: Dados pessoais mascarados
- **Audit Compliance**: Informa√ß√µes necess√°rias para auditoria
- **GDPR Compliant**: N√£o exp√µe dados pessoais completos
- **Security Metrics**: M√©tricas de seguran√ßa inclu√≠das

## üè≠ Factory Methods

### Cria√ß√£o Controlada
```csharp
public static RegisterRequestDto Create(
    string email,
    string password,
    string confirmPassword,
    string firstName,
    string lastName,
    string tenantId)
{
    return new RegisterRequestDto
    {
        Email = email?.Trim() ?? string.Empty,
        Password = password ?? string.Empty,
        ConfirmPassword = confirmPassword ?? string.Empty,
        FirstName = firstName?.Trim() ?? string.Empty,
        LastName = lastName?.Trim() ?? string.Empty,
        TenantId = tenantId?.Trim() ?? string.Empty
    };
}
```
- **Safe Construction**: Constru√ß√£o segura com normaliza√ß√£o
- **Null Safety**: Tratamento seguro de valores nulos
- **Trimming**: Remo√ß√£o autom√°tica de espa√ßos

## üîí Considera√ß√µes de Seguran√ßa

### Prote√ß√£o de Dados Sens√≠veis
- ‚ö†Ô∏è **Passwords**: Nunca logadas ou expostas
- ‚ö†Ô∏è **Personal Data**: Dados pessoais mascarados em logs
- ‚úÖ **Email Masking**: Email parcialmente mascarado
- ‚úÖ **Name Masking**: Nomes mascarados para privacidade

### Preven√ß√£o de Ataques
- **Input Validation**: Valida√ß√£o rigorosa de entrada
- **SQL Injection**: Preven√ß√£o via valida√ß√£o de entrada
- **XSS Prevention**: Valida√ß√£o de caracteres especiais
- **Rate Limiting**: Suporte a limita√ß√£o de taxa

### Compliance Regulat√≥rio
- **GDPR**: Conformidade com prote√ß√£o de dados
- **Privacy by Design**: Privacidade por design
- **Audit Trail**: Trilha de auditoria completa
- **Data Minimization**: Coleta m√≠nima de dados

## üîÑ Fluxo de Registro

### Processo Completo
1. **Client Request**: Cliente envia RegisterRequestDto
2. **Input Validation**: Valida√ß√£o de formato e regras
3. **Business Validation**: Verifica√ß√£o de duplicatas
4. **Password Strength**: Verifica√ß√£o de for√ßa da senha
5. **Terms Compliance**: Verifica√ß√£o de aceita√ß√£o de termos
6. **User Creation**: Cria√ß√£o do usu√°rio no sistema
7. **Email Verification**: Envio de email de verifica√ß√£o
8. **Response**: Resposta de sucesso ou erro

### Valida√ß√µes em Camadas
```csharp
// 1. Attribute Validation (Model Binding)
if (!ModelState.IsValid)
    return BadRequest(ModelState);

// 2. Business Validation
if (!request.IsValid())
    return BadRequest("Invalid registration data");

// 3. Domain Validation
var existingUser = await userService.GetByEmailAsync(request.NormalizedEmail, request.TenantId);
if (existingUser != null)
    return BadRequest("User already exists");
```

## üìä Performance

### Valida√ß√£o Eficiente
- **Early Exit**: Valida√ß√µes falham rapidamente
- **Compiled Regex**: Express√µes regulares compiladas
- **Minimal Allocations**: Poucas aloca√ß√µes desnecess√°rias
- **Cached Validators**: Validadores cacheados quando poss√≠vel

### Processamento Ass√≠ncrono
```csharp
public async Task<Result<UserDto>> ProcessRegistrationAsync(RegisterRequestDto request)
{
    // Valida√ß√£o s√≠ncrona r√°pida
    if (!request.IsValid())
        return Result<UserDto>.Failure("Invalid registration data");

    // Verifica√ß√µes ass√≠ncronas
    var duplicateCheck = await CheckForDuplicatesAsync(request);
    if (!duplicateCheck.IsSuccess)
        return duplicateCheck;

    // Cria√ß√£o do usu√°rio
    return await userService.CreateUserAsync(request);
}
```

## üß™ Testabilidade

### Unit Tests
```csharp
[Test]
public void IsValid_WithValidData_ShouldReturnTrue()
{
    var request = RegisterRequestDto.Create(
        "user@test.com", 
        "StrongPass123!", 
        "StrongPass123!", 
        "John", 
        "Doe", 
        "tenant1"
    );
    request.AcceptTerms = true;
    
    Assert.True(request.IsValid());
}

[Test]
public void HasStrongPassword_WithWeakPassword_ShouldReturnFalse()
{
    var request = new RegisterRequestDto { Password = "123456" };
    Assert.False(request.HasStrongPassword);
}
```

### Property-Based Tests
```csharp
[Property]
public void IsValidEmail_WithRandomValidEmails_ShouldReturnTrue(ValidEmail email)
{
    var request = new RegisterRequestDto { Email = email.Value };
    Assert.True(IsValidEmail(request.Email));
}
```

## üåê Integra√ß√£o com Frontend

### TypeScript Interface
```typescript
interface RegisterRequest {
    email: string;
    password: string;
    confirmPassword: string;
    firstName: string;
    lastName: string;
    tenantId: string;
    phoneNumber?: string;
    preferredLanguage?: string;
    timezone?: string;
    acceptTerms: boolean;
    marketingOptIn?: boolean;
    registrationSource?: string;
    metadata?: Record<string, string>;
}
```

### React Form Validation
```javascript
const useRegistrationValidation = () => {
    const validatePassword = (password) => {
        const hasUpper = /[A-Z]/.test(password);
        const hasLower = /[a-z]/.test(password);
        const hasDigit = /\d/.test(password);
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
        
        const score = [hasUpper, hasLower, hasDigit, hasSpecial].filter(Boolean).length;
        return score >= 3 && password.length >= 8;
    };
    
    return { validatePassword };
};
```

## üîÆ Extensibilidade

### Campos Customizados Futuros
```csharp
[JsonPropertyName("companyName")]
public string? CompanyName { get; set; }

[JsonPropertyName("jobTitle")]
public string? JobTitle { get; set; }

[JsonPropertyName("referralCode")]
public string? ReferralCode { get; set; }

[JsonPropertyName("privacyPolicyVersion")]
public string? PrivacyPolicyVersion { get; set; }
```

### Valida√ß√µes Adicionais
- **Company Registration**: Valida√ß√£o de empresa
- **Industry Selection**: Sele√ß√£o de setor
- **Role-Based Registration**: Registro baseado em fun√ß√£o
- **Integration Preferences**: Prefer√™ncias de integra√ß√£o

## üéØ Padr√µes de Uso

### Controller Implementation
```csharp
[HttpPost("register")]
public async Task<ActionResult<UserDto>> Register([FromBody] RegisterRequestDto request)
{
    // Enrich with metadata
    request.RegistrationSource = "web-app";
    request.Metadata ??= new Dictionary<string, string>();
    request.Metadata["ipAddress"] = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
    request.Metadata["userAgent"] = HttpContext.Request.Headers["User-Agent"].ToString();
    
    // Validate
    if (!request.IsValid())
        return BadRequest("Invalid registration data");
    
    // Process
    var result = await registrationService.RegisterUserAsync(request);
    
    return result.IsSuccess ? Ok(result.Value) : BadRequest(result.Error);
}
```

### Service Layer
```csharp
public async Task<Result<UserDto>> RegisterUserAsync(RegisterRequestDto request)
{
    // Log registration attempt (safe)
    logger.LogInformation("Registration attempt: {@RegistrationInfo}", request.GetLoggingInfo());
    
    // Check for existing user
    var existingUser = await userRepository.GetByEmailAsync(request.NormalizedEmail, request.TenantId);
    if (existingUser != null)
        return Result<UserDto>.Failure("User already exists");
    
    // Create user entity
    var user = new ApplicationUser
    {
        Email = request.NormalizedEmail,
        FirstName = request.FirstName.Trim(),
        LastName = request.LastName.Trim(),
        TenantId = request.TenantId,
        PhoneNumber = request.PhoneNumber,
        PreferredLanguage = request.PreferredLanguage,
        EmailVerified = false,
        IsActive = true,
        CreatedAt = DateTime.UtcNow
    };
    
    // Hash password
    user.PasswordHash = passwordHasher.HashPassword(user, request.Password);
    
    // Save user
    await userRepository.AddAsync(user);
    await unitOfWork.SaveChangesAsync();
    
    // Send verification email
    await emailService.SendVerificationEmailAsync(user);
    
    // Map to DTO
    var userDto = mapper.Map<UserDto>(user);
    
    return Result<UserDto>.Success(userDto);
}
```

## üéØ Boas Pr√°ticas Implementadas

### Security-First Design
- **Strong Password Requirements**: Requisitos de senha forte
- **Input Validation**: Valida√ß√£o rigorosa de entrada
- **Data Protection**: Prote√ß√£o de dados sens√≠veis
- **Audit Trail**: Trilha de auditoria completa

### User Experience
- **Clear Error Messages**: Mensagens de erro claras
- **Progressive Disclosure**: Campos opcionais separados
- **Real-time Validation**: Valida√ß√£o em tempo real
- **Accessibility**: Preparado para acessibilidade

### Compliance & Privacy
- **GDPR Compliance**: Conformidade com GDPR
- **Terms Acceptance**: Aceita√ß√£o expl√≠cita de termos
- **Data Minimization**: Coleta m√≠nima de dados
- **Privacy by Design**: Privacidade por design

### Technical Excellence
- **Comprehensive Testing**: Testabilidade completa
- **Performance Optimization**: Otimiza√ß√µes de performance
- **Extensibility**: Preparado para crescimento
- **Clean Code**: C√≥digo limpo e manuten√≠vel

---

## üìù Notas de Implementa√ß√£o

- ‚úÖ Valida√ß√£o de senha forte com verifica√ß√£o de complexidade
- ‚úÖ Preven√ß√£o de senhas comuns conhecidas
- ‚úÖ Valida√ß√£o de nomes com suporte Unicode
- ‚úÖ Compliance com GDPR atrav√©s de logging seguro
- ‚úÖ Aceita√ß√£o obrigat√≥ria de termos para compliance legal
- ‚úÖ Suporte a localiza√ß√£o e prefer√™ncias do usu√°rio
- ‚úÖ Factory method para constru√ß√£o segura
- ‚úÖ Extensibilidade atrav√©s de metadados flex√≠veis
- ‚úÖ Testabilidade garantida atrav√©s de design modular
- ‚úÖ Performance otimizada com valida√ß√µes eficientes
