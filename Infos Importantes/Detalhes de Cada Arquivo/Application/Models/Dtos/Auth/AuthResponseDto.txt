# AuthResponseDto.cs - DTO de Resposta de Autentica√ß√£o

## üìã Vis√£o Geral
DTO que encapsula todas as informa√ß√µes necess√°rias para uma autentica√ß√£o bem-sucedida, incluindo tokens JWT, informa√ß√µes do usu√°rio e metadados de sess√£o. Projetado para autentica√ß√£o segura baseada em tokens com suporte a refresh tokens.

## üèóÔ∏è Arquitetura e Estrutura

### Classe Selada
```csharp
public sealed class AuthResponseDto
```
- **Sealed**: Previne heran√ßa para manter controle de seguran√ßa
- **Immutable**: Design imut√°vel ap√≥s constru√ß√£o via factory
- **Token-Based**: Suporte completo a autentica√ß√£o JWT

## üîë Componentes de Autentica√ß√£o

### Token de Acesso JWT
```csharp
[Required]
[JsonPropertyName("token")]
public string Token { get; set; } = string.Empty;
```
- **JWT**: Token de acesso para autentica√ß√£o de API
- **Bearer**: Usado no header Authorization
- **Tempo Limitado**: Expira conforme configura√ß√£o de seguran√ßa
- **Stateless**: Cont√©m claims necess√°rias

### Refresh Token
```csharp
[Required]
[JsonPropertyName("refreshToken")]
public string RefreshToken { get; set; } = string.Empty;
```
- **Long-Lived**: Vida √∫til mais longa que access token
- **Session Management**: Mant√©m sess√µes sem re-autentica√ß√£o
- **Secure Storage**: Deve ser armazenado com seguran√ßa
- **One-Time Use**: Pode ser configurado para uso √∫nico

### Informa√ß√µes de Expira√ß√£o
```csharp
[JsonPropertyName("expiresAt")]
public DateTime ExpiresAt { get; set; }

[JsonPropertyName("expiresIn")]
public long ExpiresIn => Math.Max(0, (long)(ExpiresAt - DateTime.UtcNow).TotalSeconds);
```
- **UTC Format**: Sempre em UTC para consist√™ncia
- **ExpiresIn**: Segundos at√© expira√ß√£o (computado)
- **Client-Friendly**: Facilita gest√£o no cliente

## üë§ Informa√ß√µes do Usu√°rio

### Dados do Usu√°rio Autenticado
```csharp
[Required]
[JsonPropertyName("user")]
public UserDto User { get; set; } = null!;
```
- **Complete Profile**: Perfil completo do usu√°rio
- **Safe Data**: Apenas dados seguros (sem senhas)
- **Context**: Contexto necess√°rio para aplica√ß√£o

## üîß Metadados de Autentica√ß√£o

### Tipo de Token
```csharp
[JsonPropertyName("tokenType")]
public string TokenType { get; set; } = "Bearer";
```
- **Standard**: Seguindo padr√£o OAuth 2.0
- **HTTP Header**: Como usar no Authorization header
- **Consistent**: Valor padr√£o "Bearer"

### Escopo de Permiss√µes
```csharp
[JsonPropertyName("scope")]
public string Scope { get; set; } = "api";
```
- **Permissions**: Define permiss√µes do token
- **Granular**: Pode ser espec√≠fico por funcionalidade
- **Authorization**: Usado para controle de acesso

### Metadados Adicionais
```csharp
[JsonPropertyName("metadata")]
public IDictionary<string, object>? Metadata { get; set; }
```
- **Extensible**: Informa√ß√µes adicionais conforme necess√°rio
- **Flexible**: Suporte a diferentes tipos de dados
- **Optional**: N√£o obrigat√≥rio para funcionamento b√°sico

## ‚è∞ Gest√£o de Tempo

### Timestamp de Cria√ß√£o
```csharp
[JsonPropertyName("issuedAt")]
public DateTime IssuedAt { get; set; } = DateTime.UtcNow;
```
- **Audit Trail**: Rastreamento de quando foi emitido
- **UTC**: Sempre em UTC
- **Automatic**: Definido automaticamente na cria√ß√£o

### Valida√ß√£o de Expira√ß√£o
```csharp
[JsonPropertyName("isValid")]
public bool IsValid => DateTime.UtcNow < ExpiresAt;

[JsonPropertyName("expiresSoon")]
public bool ExpiresSoon => (ExpiresAt - DateTime.UtcNow).TotalMinutes <= 5;
```
- **Real-Time**: Status atual do token
- **Proactive**: Detecta quando refresh √© necess√°rio
- **Client Logic**: Facilita l√≥gica no frontend

## üè≠ Factory Methods

### Cria√ß√£o de Resposta Bem-Sucedida
```csharp
public static AuthResponseDto CreateSuccess(
    string token,
    string refreshToken,
    DateTime expiresAt,
    UserDto user,
    IDictionary<string, object>? metadata = null)
{
    // Valida√ß√£o de par√¢metros
    if (string.IsNullOrWhiteSpace(token))
        throw new ArgumentException("Token cannot be null or empty", nameof(token));
    
    if (string.IsNullOrWhiteSpace(refreshToken))
        throw new ArgumentException("Refresh token cannot be null or empty", nameof(refreshToken));
    
    if (user == null)
        throw new ArgumentNullException(nameof(user));

    return new AuthResponseDto
    {
        Token = token,
        RefreshToken = refreshToken,
        ExpiresAt = expiresAt,
        User = user,
        Metadata = metadata,
        IssuedAt = DateTime.UtcNow
    };
}
```
- **Parameter Validation**: Valida√ß√£o rigorosa de entrada
- **Fail-Fast**: Falha r√°pida para par√¢metros inv√°lidos
- **Consistent**: Inicializa√ß√£o consistente

## ‚úÖ M√©todos de Valida√ß√£o

### Valida√ß√£o de Resposta
```csharp
public bool IsValidResponse()
{
    return !string.IsNullOrWhiteSpace(Token) &&
           !string.IsNullOrWhiteSpace(RefreshToken) &&
           ExpiresAt > DateTime.UtcNow &&
           User != null &&
           User.IsValid() &&
           !string.IsNullOrWhiteSpace(TokenType);
}
```
- **Comprehensive**: Verifica todos os componentes cr√≠ticos
- **Business Logic**: Aplica regras de neg√≥cio
- **Chain Validation**: Valida UserDto tamb√©m

## üìã Logging e Auditoria

### Informa√ß√µes Seguras para Log
```csharp
public IDictionary<string, object> GetLoggingInfo()
{
    return new Dictionary<string, object>
    {
        ["userId"] = User?.Id ?? "unknown",
        ["userEmail"] = User?.Email ?? "unknown",
        ["tenantId"] = User?.TenantId ?? "unknown",
        ["expiresAt"] = ExpiresAt,
        ["expiresIn"] = ExpiresIn,
        ["tokenType"] = TokenType,
        ["issuedAt"] = IssuedAt,
        ["isValid"] = IsValid
    };
}
```
- **Safe Logging**: Exclui tokens sens√≠veis
- **Audit Trail**: Informa√ß√µes necess√°rias para auditoria
- **Structured**: Formato estruturado para logs

## üîí Considera√ß√µes de Seguran√ßa

### Dados Sens√≠veis
- ‚ö†Ô∏è **Token**: Deve ser protegido durante transmiss√£o
- ‚ö†Ô∏è **RefreshToken**: Armazenamento seguro obrigat√≥rio
- ‚úÖ **User Data**: Apenas dados n√£o sens√≠veis
- ‚úÖ **Metadata**: Informa√ß√µes auxiliares seguras

### Boas Pr√°ticas
- **HTTPS Only**: Transmiss√£o apenas via HTTPS
- **Secure Storage**: Tokens em storage seguro
- **Short-Lived**: Tokens de acesso com vida curta
- **Rotation**: Rota√ß√£o regular de refresh tokens

## üîÑ Ciclo de Vida do Token

### Fluxo de Autentica√ß√£o
1. **Login**: Usu√°rio faz login com credenciais
2. **Token Generation**: Sistema gera access e refresh tokens
3. **Response**: AuthResponseDto √© retornado
4. **API Calls**: Access token usado em requisi√ß√µes
5. **Refresh**: Refresh token usado quando access expira

### Gest√£o de Expira√ß√£o
```csharp
// Verifica√ß√£o antes de API call
if (authResponse.ExpiresSoon)
{
    // Refresh token proativamente
    authResponse = await authService.RefreshTokenAsync(authResponse.RefreshToken);
}
```

## üìä Performance

### Propriedades Computadas
- **Lazy Evaluation**: Calculadas quando acessadas
- **No Network**: C√°lculos locais apenas
- **Fast**: Opera√ß√µes matem√°ticas simples

### Serializa√ß√£o
- **Efficient JSON**: Serializa√ß√£o otimizada
- **Minimal Payload**: Apenas dados necess√°rios
- **Compression**: Compat√≠vel com compress√£o HTTP

## üß™ Testabilidade

### Unit Testing
```csharp
[Test]
public void CreateSuccess_WithValidParameters_ShouldCreateValidResponse()
{
    // Arrange
    var token = "valid.jwt.token";
    var refreshToken = Guid.NewGuid().ToString();
    var expiresAt = DateTime.UtcNow.AddHours(1);
    var user = CreateValidUserDto();

    // Act
    var response = AuthResponseDto.CreateSuccess(token, refreshToken, expiresAt, user);

    // Assert
    Assert.True(response.IsValidResponse());
    Assert.Equal(token, response.Token);
    Assert.Equal(refreshToken, response.RefreshToken);
}
```

### Integration Testing
```csharp
[Test]
public async Task Login_WithValidCredentials_ShouldReturnValidAuthResponse()
{
    var response = await authService.LoginAsync(validCredentials);
    
    Assert.NotNull(response);
    Assert.True(response.IsValidResponse());
    Assert.NotEmpty(response.Token);
}
```

## üåê Integra√ß√£o com Frontend

### Armazenamento Seguro
```javascript
// Exemplo de uso no frontend
localStorage.setItem('accessToken', authResponse.token);
sessionStorage.setItem('refreshToken', authResponse.refreshToken);
```

### Verifica√ß√£o de Expira√ß√£o
```javascript
if (authResponse.expiresSoon) {
    // Refresh token antes de pr√≥xima requisi√ß√£o
    await refreshToken();
}
```

### Header de Autoriza√ß√£o
```javascript
const headers = {
    'Authorization': `${authResponse.tokenType} ${authResponse.token}`
};
```

## üîÆ Extensibilidade

### Metadados Customizados
```csharp
var metadata = new Dictionary<string, object>
{
    ["deviceId"] = request.DeviceId,
    ["loginMethod"] = "email",
    ["location"] = request.Location
};

var response = AuthResponseDto.CreateSuccess(token, refreshToken, expiresAt, user, metadata);
```

### Campos Adicionais
- **Device Information**: Informa√ß√µes do dispositivo
- **Location Data**: Dados de localiza√ß√£o
- **Session Context**: Contexto da sess√£o
- **Feature Flags**: Flags de funcionalidades

## üéØ Padr√µes de Uso

### Controller Response
```csharp
[HttpPost("login")]
public async Task<ActionResult<AuthResponseDto>> Login([FromBody] LoginRequestDto request)
{
    var result = await authService.LoginAsync(request);
    
    if (result.IsSuccess)
        return Ok(result.Value);
    
    return BadRequest(result.Error);
}
```

### Service Layer
```csharp
public async Task<Result<AuthResponseDto>> LoginAsync(LoginRequestDto request)
{
    // Authenticate user
    var user = await authenticateUser(request);
    
    // Generate tokens
    var tokens = await tokenService.GenerateTokensAsync(user);
    
    // Create response
    var response = AuthResponseDto.CreateSuccess(
        tokens.AccessToken,
        tokens.RefreshToken,
        tokens.ExpiresAt,
        mapper.Map<UserDto>(user)
    );
    
    return Result<AuthResponseDto>.Success(response);
}
```

## üéØ Boas Pr√°ticas Implementadas

### Security-First Design
- **Token Protection**: Tokens tratados como dados sens√≠veis
- **Validation**: Valida√ß√£o rigorosa em todos os n√≠veis
- **Logging**: Logs seguros sem vazamento de dados

### API Design
- **Consistent**: Estrutura consistente de resposta
- **Self-Descriptive**: Campos auto-explicativos
- **Extensible**: Preparado para futuras necessidades

### Error Prevention
- **Factory Pattern**: Constru√ß√£o controlada via factory
- **Parameter Validation**: Valida√ß√£o de entrada rigorosa
- **Fail-Fast**: Falhas detectadas rapidamente

---

## üìù Notas de Implementa√ß√£o

- ‚úÖ Factory method garante constru√ß√£o segura
- ‚úÖ Propriedades computadas para gest√£o de tempo
- ‚úÖ Valida√ß√£o abrangente implementada
- ‚úÖ Logging seguro sem exposi√ß√£o de tokens
- ‚úÖ Metadados extens√≠veis para futuras necessidades
- ‚úÖ Integra√ß√£o facilitada com frontends
- ‚úÖ Testabilidade garantida atrav√©s de design
- ‚úÖ Performance otimizada com c√°lculos locais
