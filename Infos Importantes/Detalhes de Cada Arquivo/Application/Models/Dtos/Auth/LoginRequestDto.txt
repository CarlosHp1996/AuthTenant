# LoginRequestDto.cs - DTO de Requisi√ß√£o de Login

## üìã Vis√£o Geral
DTO para requisi√ß√µes de autentica√ß√£o de usu√°rio em ambiente multi-tenant. Cont√©m valida√ß√µes abrangentes, recursos de seguran√ßa e suporte a auditoria para garantir autentica√ß√£o segura e rastre√°vel.

## üèóÔ∏è Arquitetura e Estrutura

### Classe Selada
```csharp
public sealed class LoginRequestDto
```
- **Sealed**: Previne heran√ßa para manter controle de seguran√ßa
- **Input Validation**: Foco em valida√ß√£o rigorosa de entrada
- **Multi-Tenant**: Suporte nativo √† arquitetura multi-tenant

## üîê Credenciais de Autentica√ß√£o

### Email do Usu√°rio
```csharp
[Required(ErrorMessage = "Email address is required")]
[EmailAddress(ErrorMessage = "Please provide a valid email address")]
[StringLength(256, ErrorMessage = "Email address cannot exceed 256 characters")]
[JsonPropertyName("email")]
public string Email { get; set; } = string.Empty;
```
- **Primary Identifier**: Identificador principal para autentica√ß√£o
- **Format Validation**: Valida√ß√£o rigorosa de formato de email
- **Length Limits**: M√°ximo 256 caracteres (padr√£o RFC)
- **Case Insensitive**: Processado em lowercase

### Senha do Usu√°rio
```csharp
[Required(ErrorMessage = "Password is required")]
[StringLength(128, MinimumLength = 6, ErrorMessage = "Password must be between 6 and 128 characters")]
[DataType(DataType.Password)]
[JsonPropertyName("password")]
public string Password { get; set; } = string.Empty;
```
- **Secure Input**: Marcado como DataType.Password
- **Length Requirements**: 6-128 caracteres
- **Never Logged**: Exclu√≠do de logs por seguran√ßa
- **Hashed Comparison**: Comparado com hash armazenado

### Identificador do Tenant
```csharp
[Required(ErrorMessage = "Tenant ID is required")]
[StringLength(50, MinimumLength = 1, ErrorMessage = "Tenant ID must be between 1 and 50 characters")]
[JsonPropertyName("tenantId")]
public string TenantId { get; set; } = string.Empty;
```
- **Multi-Tenancy**: Essencial para isolamento de dados
- **Data Isolation**: Garante acesso apenas ao tenant correto
- **Validation**: Formato validado (alfanum√©rico, h√≠fen, underscore)

## üîí Recursos de Seguran√ßa

### Lembrar Login
```csharp
[JsonPropertyName("rememberMe")]
public bool RememberMe { get; set; } = false;
```
- **Extended Session**: Estende dura√ß√£o da sess√£o
- **Refresh Token**: Aumenta vida √∫til do refresh token
- **User Choice**: Opcional, default false

### Informa√ß√µes do Cliente
```csharp
[StringLength(200)]
[JsonPropertyName("clientInfo")]
public string? ClientInfo { get; set; }

[JsonPropertyName("ipAddress")]
public string? IpAddress { get; set; }

[JsonPropertyName("userAgent")]
public string? UserAgent { get; set; }
```
- **Security Monitoring**: Rastreamento de origem da requisi√ß√£o
- **Fraud Detection**: Detec√ß√£o de atividades suspeitas
- **Audit Trail**: Trilha de auditoria completa

### Contexto de Seguran√ßa
```csharp
[JsonPropertyName("securityContext")]
public IDictionary<string, string>? SecurityContext { get; set; }
```
- **Extensible**: Contexto adicional conforme necess√°rio
- **Device Fingerprinting**: Impress√£o digital do dispositivo
- **Location Data**: Dados de geolocaliza√ß√£o
- **Risk Assessment**: Avalia√ß√£o de risco da tentativa

## üß† Propriedades Computadas

### Email Normalizado
```csharp
[JsonIgnore]
public string NormalizedEmail => Email.Trim().ToLowerInvariant();
```
- **Consistent Lookup**: Busca consistente no banco
- **Case Insensitive**: Remove diferen√ßas de case
- **Whitespace Removal**: Remove espa√ßos desnecess√°rios

### Detec√ß√£o de Suspeita
```csharp
[JsonIgnore]
public bool IsSuspicious => 
    string.IsNullOrWhiteSpace(ClientInfo) ||
    string.IsNullOrWhiteSpace(UserAgent) ||
    Password.Length < 8;
```
- **Basic Heuristics**: Heur√≠sticas b√°sicas de seguran√ßa
- **Alert System**: Pode disparar alertas de seguran√ßa
- **Risk Scoring**: Contribui para score de risco

## ‚úÖ M√©todos de Valida√ß√£o

### Valida√ß√£o Completa
```csharp
public bool IsValid()
{
    return !string.IsNullOrWhiteSpace(Email) &&
           !string.IsNullOrWhiteSpace(Password) &&
           !string.IsNullOrWhiteSpace(TenantId) &&
           IsValidEmail(Email) &&
           IsValidPassword(Password) &&
           IsValidTenantId(TenantId);
}
```
- **Comprehensive**: Valida√ß√£o completa de todos os campos
- **Business Rules**: Aplica regras de neg√≥cio espec√≠ficas
- **Chain Validation**: Valida√ß√µes em cascata

### Valida√ß√£o de Email
```csharp
private static bool IsValidEmail(string email)
{
    if (string.IsNullOrWhiteSpace(email) || email.Length > 256)
        return false;

    try
    {
        var addr = new System.Net.Mail.MailAddress(email);
        return addr.Address == email;
    }
    catch
    {
        return false;
    }
}
```
- **Framework Native**: Usa valida√ß√£o do .NET Framework
- **Exception Safe**: N√£o propaga exce√ß√µes
- **RFC Compliant**: Segue padr√µes RFC para email

### Valida√ß√£o de Senha
```csharp
private static bool IsValidPassword(string password)
{
    return !string.IsNullOrWhiteSpace(password) &&
           password.Length >= 6 &&
           password.Length <= 128;
}
```
- **Length Bounds**: Verifica limites de tamanho
- **Not Empty**: Garante que n√£o √© vazia
- **Security Baseline**: Requisitos m√≠nimos de seguran√ßa

### Valida√ß√£o de Tenant ID
```csharp
private static bool IsValidTenantId(string tenantId)
{
    return !string.IsNullOrWhiteSpace(tenantId) &&
           tenantId.Length <= 50 &&
           tenantId.All(c => char.IsLetterOrDigit(c) || c == '-' || c == '_');
}
```
- **Character Whitelist**: Apenas caracteres permitidos
- **Length Limit**: M√°ximo 50 caracteres
- **URL Safe**: Caracteres seguros para URLs

## üìã Logging e Auditoria

### Informa√ß√µes Seguras para Log
```csharp
public IDictionary<string, object> GetLoggingInfo()
{
    return new Dictionary<string, object>
    {
        ["email"] = Email.Length > 0 ? $"{Email[0]}***@{Email.Split('@').LastOrDefault()}" : "unknown",
        ["tenantId"] = TenantId,
        ["rememberMe"] = RememberMe,
        ["hasClientInfo"] = !string.IsNullOrWhiteSpace(ClientInfo),
        ["hasUserAgent"] = !string.IsNullOrWhiteSpace(UserAgent),
        ["ipAddress"] = IpAddress ?? "unknown",
        ["isSuspicious"] = IsSuspicious,
        ["timestamp"] = DateTime.UtcNow
    };
}
```
- **Data Protection**: Email mascarado para privacidade
- **Audit Trail**: Informa√ß√µes necess√°rias para auditoria
- **Security Context**: Contexto de seguran√ßa preservado
- **No Sensitive Data**: Senhas nunca inclu√≠das

## üè≠ Factory Methods

### Cria√ß√£o de Requisi√ß√£o
```csharp
public static LoginRequestDto Create(string email, string password, string tenantId, bool rememberMe = false)
{
    return new LoginRequestDto
    {
        Email = email?.Trim() ?? string.Empty,
        Password = password ?? string.Empty,
        TenantId = tenantId?.Trim() ?? string.Empty,
        RememberMe = rememberMe
    };
}
```
- **Safe Construction**: Constru√ß√£o segura com valida√ß√£o
- **Null Safety**: Lida com valores nulos graciosamente
- **Default Values**: Valores padr√£o apropriados

## üîí Considera√ß√µes de Seguran√ßa

### Prote√ß√£o de Dados Sens√≠veis
- ‚ö†Ô∏è **Password**: Nunca logado ou exposto
- ‚úÖ **Email**: Mascarado em logs
- ‚úÖ **IP Address**: Rastreado para seguran√ßa
- ‚úÖ **User Agent**: Monitorado para detec√ß√£o de bots

### Preven√ß√£o de Ataques
- **Rate Limiting**: Suporte a rate limiting por IP/tenant
- **Brute Force**: Detec√ß√£o de tentativas de for√ßa bruta
- **Bot Detection**: Detec√ß√£o de atividade automatizada
- **Geo-Blocking**: Bloqueio baseado em geolocaliza√ß√£o

### Compliance
- **GDPR**: Conformidade com prote√ß√£o de dados
- **Audit Logs**: Logs de auditoria completos
- **Data Retention**: Pol√≠ticas de reten√ß√£o de dados
- **Privacy**: Prote√ß√£o da privacidade do usu√°rio

## üîÑ Fluxo de Autentica√ß√£o

### Processo de Login
1. **Client Request**: Cliente envia LoginRequestDto
2. **Validation**: Valida√ß√£o de formato e regras
3. **Tenant Lookup**: Verifica√ß√£o de tenant v√°lido
4. **User Authentication**: Autentica√ß√£o de credenciais
5. **Security Checks**: Verifica√ß√µes de seguran√ßa
6. **Token Generation**: Gera√ß√£o de tokens
7. **Response**: AuthResponseDto retornado

### Tratamento de Erros
```csharp
if (!request.IsValid())
    return BadRequest("Invalid login request");

if (request.IsSuspicious)
    await securityService.LogSuspiciousActivity(request);
```

## üìä Performance

### Valida√ß√£o Eficiente
- **Early Exit**: Valida√ß√µes falham rapidamente
- **Minimal Allocation**: Poucas aloca√ß√µes desnecess√°rias
- **Cached Patterns**: Patterns de valida√ß√£o cacheados

### Processamento Ass√≠ncrono
```csharp
public async Task<Result<AuthResponseDto>> ProcessLoginAsync(LoginRequestDto request)
{
    // Valida√ß√£o s√≠ncrona r√°pida
    if (!request.IsValid())
        return Result<AuthResponseDto>.Failure("Invalid request");

    // Processamento ass√≠ncrono
    return await authService.AuthenticateAsync(request);
}
```

## üß™ Testabilidade

### Unit Tests
```csharp
[Test]
public void IsValid_WithValidData_ShouldReturnTrue()
{
    var request = LoginRequestDto.Create("user@test.com", "password123", "tenant1");
    Assert.True(request.IsValid());
}

[Test]
public void IsSuspicious_WithMissingUserAgent_ShouldReturnTrue()
{
    var request = new LoginRequestDto { /* ... */ };
    Assert.True(request.IsSuspicious);
}
```

### Integration Tests
```csharp
[Test]
public async Task Login_WithValidRequest_ShouldSucceed()
{
    var request = CreateValidLoginRequest();
    var response = await authController.Login(request);
    
    Assert.IsType<OkObjectResult>(response.Result);
}
```

## üåê Integra√ß√£o com Frontend

### JavaScript/TypeScript
```typescript
interface LoginRequest {
    email: string;
    password: string;
    tenantId: string;
    rememberMe?: boolean;
    clientInfo?: string;
    ipAddress?: string;
    userAgent?: string;
}

const loginRequest: LoginRequest = {
    email: user.email,
    password: user.password,
    tenantId: getCurrentTenant(),
    rememberMe: user.rememberMe,
    clientInfo: getDeviceInfo(),
    userAgent: navigator.userAgent
};
```

### React Hook
```javascript
const useLogin = () => {
    const login = async (email, password, tenantId, rememberMe = false) => {
        const request = {
            email,
            password,
            tenantId,
            rememberMe,
            clientInfo: getClientInfo(),
            userAgent: navigator.userAgent,
            ipAddress: await getPublicIP()
        };
        
        return await authService.login(request);
    };
    
    return { login };
};
```

## üîÆ Extensibilidade

### Campos Customizados
```csharp
[JsonPropertyName("captchaToken")]
public string? CaptchaToken { get; set; }

[JsonPropertyName("mfaCode")]
public string? MfaCode { get; set; }

[JsonPropertyName("deviceFingerprint")]
public string? DeviceFingerprint { get; set; }
```

### Valida√ß√µes Adicionais
- **CAPTCHA**: Valida√ß√£o de CAPTCHA
- **MFA**: Multi-Factor Authentication
- **Device Trust**: Confian√ßa do dispositivo
- **Geo-Validation**: Valida√ß√£o geogr√°fica

## üéØ Padr√µes de Uso

### Controller Implementation
```csharp
[HttpPost("login")]
public async Task<ActionResult<AuthResponseDto>> Login([FromBody] LoginRequestDto request)
{
    // Enrich request with context
    request.IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString();
    request.UserAgent = HttpContext.Request.Headers["User-Agent"].ToString();
    
    // Validate request
    if (!request.IsValid())
        return BadRequest("Invalid login request");
    
    // Process login
    var result = await authService.LoginAsync(request);
    
    return result.IsSuccess ? Ok(result.Value) : BadRequest(result.Error);
}
```

### Service Layer
```csharp
public async Task<Result<AuthResponseDto>> LoginAsync(LoginRequestDto request)
{
    // Log attempt (safe)
    logger.LogInformation("Login attempt: {@LoginInfo}", request.GetLoggingInfo());
    
    // Validate tenant
    var tenant = await tenantService.GetByIdAsync(request.TenantId);
    if (tenant == null)
        return Result<AuthResponseDto>.Failure("Invalid tenant");
    
    // Authenticate user
    var user = await userService.AuthenticateAsync(request.NormalizedEmail, request.Password, request.TenantId);
    if (user == null)
        return Result<AuthResponseDto>.Failure("Invalid credentials");
    
    // Generate tokens
    var tokens = await tokenService.GenerateTokensAsync(user, request.RememberMe);
    
    // Create response
    var response = AuthResponseDto.CreateSuccess(tokens.AccessToken, tokens.RefreshToken, tokens.ExpiresAt, mapper.Map<UserDto>(user));
    
    return Result<AuthResponseDto>.Success(response);
}
```

## üéØ Boas Pr√°ticas Implementadas

### Security by Design
- **Input Validation**: Valida√ß√£o rigorosa de entrada
- **Data Protection**: Prote√ß√£o de dados sens√≠veis
- **Audit Trail**: Trilha de auditoria completa
- **Threat Detection**: Detec√ß√£o de amea√ßas b√°sicas

### API Design
- **Clear Contracts**: Contratos claros e bem definidos
- **Error Handling**: Tratamento de erro consistente
- **Extensibility**: Preparado para futuras necessidades
- **Documentation**: Documenta√ß√£o abrangente

### Performance
- **Efficient Validation**: Valida√ß√µes eficientes
- **Early Exit**: Falhas r√°pidas para casos inv√°lidos
- **Minimal Allocation**: Poucas aloca√ß√µes desnecess√°rias

---

## üìù Notas de Implementa√ß√£o

- ‚úÖ Valida√ß√£o abrangente implementada para todos os campos
- ‚úÖ Seguran√ßa garantida atrav√©s de logging seguro
- ‚úÖ Multi-tenancy suportado nativamente
- ‚úÖ Detec√ß√£o b√°sica de atividades suspeitas
- ‚úÖ Factory method para constru√ß√£o segura
- ‚úÖ Propriedades computadas para facilitar uso
- ‚úÖ Testabilidade garantida atrav√©s de design
- ‚úÖ Extensibilidade preparada para futuras necessidades
