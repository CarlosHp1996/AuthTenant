# TokenService.cs - Documenta√ß√£o T√©cnica

## üìã Vis√£o Geral
O `TokenService` √© uma implementa√ß√£o enterprise completa para gera√ß√£o, valida√ß√£o e manipula√ß√£o de tokens JWT. Projetado para sistemas de alta disponibilidade com suporte a multi-tenancy, observabilidade avan√ßada e padr√µes de seguran√ßa enterprise. Implementa todas as opera√ß√µes necess√°rias para um sistema de autentica√ß√£o robusto e escal√°vel.

## üèóÔ∏è Arquitetura e Design

### Padr√µes Implementados
- **Service Layer Pattern**: Encapsulamento de l√≥gica de neg√≥cio
- **Dependency Injection**: Invers√£o de depend√™ncias via DI
- **Result Pattern**: Controle consistente de erro sem exce√ß√µes
- **Lazy Loading**: Carregamento sob demanda das configura√ß√µes JWT
- **Factory Pattern**: Cria√ß√£o de tokens e configura√ß√µes
- **Strategy Pattern**: Diferentes estrat√©gias de valida√ß√£o
- **Template Method**: Padroniza√ß√£o de valida√ß√µes

### Princ√≠pios SOLID
- **SRP**: Responsabilidade √∫nica para opera√ß√µes JWT
- **OCP**: Extens√≠vel via heran√ßa e composi√ß√£o
- **LSP**: Implementa ITokenService de forma substitu√≠vel
- **ISP**: Interface espec√≠fica sem m√©todos desnecess√°rios
- **DIP**: Depende de abstra√ß√µes (IConfiguration, ILogger)

## üîß Depend√™ncias e Configura√ß√£o

### Servi√ßos Injetados
```csharp
IConfiguration _configuration           // Configura√ß√µes da aplica√ß√£o
ILogger<TokenService> _logger          // Logging estruturado
JwtSecurityTokenHandler _tokenHandler  // Handler JWT do .NET
Lazy<JwtSettings> _jwtSettings         // Configura√ß√µes JWT lazy-loaded
```

### Configura√ß√£o Required (appsettings.json)
```json
{
  "JwtSettings": {
    "Secret": "your-super-secret-jwt-key-minimum-256-bits",
    "Issuer": "AuthTenant.API",
    "Audience": "AuthTenant.Client",
    "ExpiryInMinutes": "60"
  }
}
```

### Valida√ß√µes de Configura√ß√£o
```csharp
private JwtSettings GetJwtSettings()
{
    // Valida√ß√£o rigorosa de todas as configura√ß√µes
    // Fallbacks seguros para valores padr√£o
    // Logging de configura√ß√µes inv√°lidas
    // Exce√ß√µes espec√≠ficas para cada erro
}
```

## üöÄ Implementa√ß√£o dos M√©todos Principais

### GenerateJwtTokenAsync
```csharp
public async Task<Result<string>> GenerateJwtTokenAsync(ApplicationUser user, CancellationToken cancellationToken = default)
```

**Pipeline de Execu√ß√£o:**
1. **Valida√ß√£o de Entrada**
   ```csharp
   // Valida√ß√£o de user != null
   // Valida√ß√£o de user.Id n√£o vazio
   // Valida√ß√£o de user.TenantId n√£o vazio
   // Logging de tentativas inv√°lidas
   ```

2. **Constru√ß√£o de Claims**
   ```csharp
   var claims = await BuildUserClaimsAsync(user, cancellationToken);
   // ClaimTypes.NameIdentifier (user.Id)
   // ClaimTypes.Email (user.Email)
   // ClaimTypes.Name (user.UserName)
   // ClaimTypes.GivenName (user.FirstName)
   // ClaimTypes.Surname (user.LastName)
   // TenantConstants.TenantIdClaimType (user.TenantId)
   // JwtRegisteredClaimNames.Jti (unique token ID)
   // JwtRegisteredClaimNames.Iat (issued at timestamp)
   ```

3. **Cria√ß√£o do Token Descriptor**
   ```csharp
   var tokenDescriptor = new SecurityTokenDescriptor
   {
       Subject = new ClaimsIdentity(claims),
       Expires = DateTime.UtcNow.AddMinutes(settings.ExpiryInMinutes),
       SigningCredentials = new SigningCredentials(/*...*/),
       Issuer = settings.Issuer,
       Audience = settings.Audience,
       IssuedAt = DateTime.UtcNow,
       NotBefore = DateTime.UtcNow
   };
   ```

4. **Gera√ß√£o e Logging**
   ```csharp
   var token = _tokenHandler.CreateToken(tokenDescriptor);
   var tokenString = _tokenHandler.WriteToken(token);
   _logger.LogInformation("JWT token successfully generated for user {UserId}", user.Id);
   ```

### GetPrincipalFromExpiredTokenAsync
```csharp
public Task<Result<ClaimsPrincipal>> GetPrincipalFromExpiredTokenAsync(string token, CancellationToken cancellationToken = default)
```

**Pipeline de Execu√ß√£o:**
1. **Valida√ß√£o de Token**
   ```csharp
   var tokenValidationResult = ValidateTokenInput(token);
   // Verifica√ß√£o de null/empty
   // Verifica√ß√£o de formato JWT (3 partes)
   // Logging de tentativas inv√°lidas
   ```

2. **Configura√ß√£o de Valida√ß√£o Especial**
   ```csharp
   var tokenValidationParameters = CreateTokenValidationParameters(settings, validateLifetime: false);
   // ValidateLifetime = false (permite tokens expirados)
   // Outras valida√ß√µes permanecem ativas
   ```

3. **Extra√ß√£o de Principal**
   ```csharp
   var principal = _tokenHandler.ValidateToken(token, tokenValidationParameters, out var securityToken);
   // Valida√ß√£o de algoritmo de seguran√ßa
   // Extra√ß√£o de claims do token expirado
   ```

### ValidateTokenAsync
```csharp
public Task<Result<ClaimsPrincipal>> ValidateTokenAsync(string token, CancellationToken cancellationToken = default)
```

**Pipeline de Execu√ß√£o:**
1. **Valida√ß√£o Completa**
   ```csharp
   var tokenValidationParameters = CreateTokenValidationParameters(settings, validateLifetime: true);
   // ValidateLifetime = true (rejeita tokens expirados)
   // Valida√ß√£o completa de seguran√ßa
   ```

2. **Tratamento de Exce√ß√µes Espec√≠ficas**
   ```csharp
   catch (SecurityTokenExpiredException)
   {
       return Result<ClaimsPrincipal>.Failure("Token has expired");
   }
   catch (SecurityTokenException ex)
   {
       return Result<ClaimsPrincipal>.Failure("Invalid token");
   }
   ```

### GenerateRefreshTokenAsync
```csharp
public Task<Result<string>> GenerateRefreshTokenAsync(CancellationToken cancellationToken = default)
```

**Gera√ß√£o Criptograficamente Segura:**
```csharp
var randomBytes = new byte[32];
using var rng = RandomNumberGenerator.Create();
rng.GetBytes(randomBytes);
var refreshToken = Convert.ToBase64String(randomBytes);
```

**Caracter√≠sticas:**
- 32 bytes de entropia (256 bits)
- RandomNumberGenerator.Create() (CSPRNG)
- Base64 encoding para transporte
- Sem informa√ß√µes embedded (stateless)

## üîç M√©todos de Extra√ß√£o de Claims

### GetTenantIdFromTokenAsync
```csharp
public async Task<Result<string>> GetTenantIdFromTokenAsync(string token, CancellationToken cancellationToken = default)
```

**Implementa√ß√£o Multi-Tenant:**
```csharp
var principalResult = await ValidateTokenAsync(token, cancellationToken);
var tenantId = principalResult.Data?.FindFirst(TenantConstants.TenantIdClaimType)?.Value;

if (string.IsNullOrWhiteSpace(tenantId))
{
    return Result<string>.Failure("Tenant ID not found in token");
}
```

### GetUserIdFromTokenAsync
```csharp
public async Task<Result<string>> GetUserIdFromTokenAsync(string token, CancellationToken cancellationToken = default)
```

**Extra√ß√£o de Identidade:**
```csharp
var userId = principalResult.Data?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
// Claim padr√£o para identifica√ß√£o de usu√°rio
// Valida√ß√£o de presen√ßa obrigat√≥ria
```

### IsTokenExpiredAsync
```csharp
public Task<Result<bool>> IsTokenExpiredAsync(string token, CancellationToken cancellationToken = default)
```

**Verifica√ß√£o R√°pida:**
```csharp
var jwtToken = _tokenHandler.ReadJwtToken(token);
var isExpired = jwtToken.ValidTo < DateTime.UtcNow;
// Verifica√ß√£o sem valida√ß√£o custosa
// √ötil para UI feedback
```

## üîÑ Legacy Support Methods

### Wrapper para Compatibilidade
```csharp
[Obsolete("Use GenerateJwtTokenAsync para melhor controle de erro e opera√ß√µes ass√≠ncronas.", false)]
public string GenerateJwtToken(ApplicationUser user)
{
    var result = GenerateJwtTokenAsync(user).GetAwaiter().GetResult();
    
    if (!result.IsSuccess)
    {
        throw new InvalidOperationException(result.Error ?? "Failed to generate JWT token");
    }
    
    return result.Data ?? throw new InvalidOperationException("Generated token is null");
}
```

**Estrat√©gia de Migra√ß√£o:**
- M√©todos marcados como [Obsolete]
- Wrapper que chama vers√µes async
- Convers√£o de Result para Exception (legacy behavior)
- Warnings de compila√ß√£o para incentivar migra√ß√£o

## üîí Implementa√ß√£o de Seguran√ßa

### Valida√ß√£o de Token Input
```csharp
private Result<bool> ValidateTokenInput(string token)
{
    // Verifica√ß√£o de null/empty
    if (string.IsNullOrWhiteSpace(token))
        return Result<bool>.Failure("Token cannot be null or empty");

    // Verifica√ß√£o de formato JWT (header.payload.signature)
    var parts = token.Split('.');
    if (parts.Length != 3)
        return Result<bool>.Failure("Invalid token format");

    return Result<bool>.Success(true);
}
```

### Par√¢metros de Valida√ß√£o Seguros
```csharp
private TokenValidationParameters CreateTokenValidationParameters(JwtSettings settings, bool validateLifetime)
{
    return new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,        // Sempre validar assinatura
        IssuerSigningKey = new SymmetricSecurityKey(settings.SecretKey),
        ValidateIssuer = true,                  // Validar emissor
        ValidIssuer = settings.Issuer,
        ValidateAudience = true,                // Validar audi√™ncia
        ValidAudience = settings.Audience,
        ValidateLifetime = validateLifetime,    // Configur√°vel
        ClockSkew = TimeSpan.FromMinutes(5),    // Toler√¢ncia de rel√≥gio
        RequireExpirationTime = true,           // Exigir tempo de expira√ß√£o
        RequireSignedTokens = true              // Exigir tokens assinados
    };
}
```

### Valida√ß√£o de Algoritmo
```csharp
private static bool IsValidSecurityToken(SecurityToken securityToken)
{
    return securityToken is JwtSecurityToken jwtSecurityToken &&
           jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase);
}
```

## üìä Logging e Observabilidade

### Structured Logging
```csharp
// Debug level - opera√ß√µes normais
_logger.LogDebug("Generating JWT token for user {UserId} in tenant {TenantId}", user.Id, user.TenantId);

// Information level - opera√ß√µes importantes
_logger.LogInformation("JWT token successfully generated for user {UserId}", user.Id);

// Warning level - situa√ß√µes an√¥malas n√£o cr√≠ticas
_logger.LogWarning("Attempted to generate JWT token for user {UserId} without tenant", user.Id);
_logger.LogWarning("Invalid token algorithm detected");

// Error level - erros que impedem opera√ß√£o
_logger.LogError(ex, "Error generating JWT token for user {UserId}", user?.Id ?? "null");
```

### Auditoria de Seguran√ßa
```csharp
// Claims building audit
_logger.LogDebug("Built {ClaimCount} claims for user {UserId}", claims.Count, user.Id);

// Token validation audit
_logger.LogDebug("Token expiration check: {IsExpired} (Expires: {ExpiryTime})", isExpired, jwtToken.ValidTo);

// Security warnings
_logger.LogWarning("Token validation attempted with null or empty token");
_logger.LogWarning("Token validation attempted with invalid JWT format");
```

## ‚ö° Performance Optimizations

### Lazy Configuration Loading
```csharp
private readonly Lazy<JwtSettings> _jwtSettings;

public TokenService(IConfiguration configuration, ILogger<TokenService> logger)
{
    _jwtSettings = new Lazy<JwtSettings>(() => GetJwtSettings());
    // Configura√ß√µes carregadas apenas quando necess√°rio
    // Cache autom√°tico ap√≥s primeira utiliza√ß√£o
}
```

### Efficient Token Handler
```csharp
private readonly JwtSecurityTokenHandler _tokenHandler;
// Reutiliza√ß√£o da mesma inst√¢ncia
// Evita overhead de cria√ß√£o repetida
```

### Task-Based Async Operations
```csharp
public Task<Result<string>> GenerateJwtTokenAsync(/*...*/)
{
    // Opera√ß√µes I/O bound s√£o ass√≠ncronas
    // CPU-bound operations usam Task.FromResult para evitar overhead
    return Task.FromResult(Result<string>.Success(tokenString));
}
```

## üß™ Error Handling Strategy

### Result Pattern Implementation
```csharp
// Success case
return Result<string>.Success(tokenString);

// Failure cases with specific messages
return Result<string>.Failure("User cannot be null");
return Result<string>.Failure("User ID is required");
return Result<string>.Failure("Tenant ID is required");
return Result<string>.Failure("Failed to generate JWT token");
```

### Exception to Result Conversion
```csharp
try
{
    // Token operation
}
catch (SecurityTokenException ex)
{
    _logger.LogWarning(ex, "Security token validation failed");
    return Task.FromResult(Result<ClaimsPrincipal>.Failure("Invalid token format"));
}
catch (Exception ex)
{
    _logger.LogError(ex, "Error extracting principal from expired token");
    return Task.FromResult(Result<ClaimsPrincipal>.Failure("Failed to process token"));
}
```

## üéØ Claims Management

### Standard Claims Implementation
```csharp
private Task<IList<Claim>> BuildUserClaimsAsync(ApplicationUser user, CancellationToken cancellationToken)
{
    var claims = new List<Claim>
    {
        new(ClaimTypes.NameIdentifier, user.Id),                    // User ID
        new(ClaimTypes.Email, user.Email ?? string.Empty),         // Email
        new(ClaimTypes.Name, user.UserName ?? string.Empty),       // Username
        new(ClaimTypes.GivenName, user.FirstName ?? string.Empty), // First name
        new(ClaimTypes.Surname, user.LastName ?? string.Empty),    // Last name
        new(TenantConstants.TenantIdClaimType, user.TenantId),      // Tenant ID
        new(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), // JWT ID
        new(JwtRegisteredClaimNames.Iat,                             // Issued at
            new DateTimeOffset(DateTime.UtcNow).ToUnixTimeSeconds().ToString(), 
            ClaimValueTypes.Integer64)
    };
    
    return Task.FromResult<IList<Claim>>(claims);
}
```

### Multi-Tenant Claims
```csharp
// Tenant isolation atrav√©s de claims
new(TenantConstants.TenantIdClaimType, user.TenantId)

// Extra√ß√£o para opera√ß√µes multi-tenant
var tenantId = principalResult.Data?.FindFirst(TenantConstants.TenantIdClaimType)?.Value;
```

## üìà Configura√ß√£o Enterprise

### JwtSettings Inner Class
```csharp
private sealed class JwtSettings
{
    public byte[] SecretKey { get; init; } = Array.Empty<byte>();
    public string Issuer { get; init; } = string.Empty;
    public string Audience { get; init; } = string.Empty;
    public int ExpiryInMinutes { get; init; }
}
```

### Configuration Validation
```csharp
private JwtSettings GetJwtSettings()
{
    var jwtSection = _configuration.GetSection("JwtSettings");
    
    // Valida√ß√£o de Secret
    var secret = jwtSection["Secret"];
    if (string.IsNullOrWhiteSpace(secret))
        throw new InvalidOperationException("JWT Secret not configured in appsettings");

    // Valida√ß√£o de Issuer
    var issuer = jwtSection["Issuer"];
    if (string.IsNullOrWhiteSpace(issuer))
        throw new InvalidOperationException("JWT Issuer not configured in appsettings");

    // Valida√ß√£o de Audience
    var audience = jwtSection["Audience"];
    if (string.IsNullOrWhiteSpace(audience))
        throw new InvalidOperationException("JWT Audience not configured in appsettings");

    // Valida√ß√£o de ExpiryInMinutes com fallback
    if (!int.TryParse(jwtSection["ExpiryInMinutes"], out var expiryInMinutes) || expiryInMinutes <= 0)
    {
        expiryInMinutes = 60; // Fallback seguro
        _logger.LogWarning("Invalid or missing JWT ExpiryInMinutes, using default value: {DefaultExpiry}", expiryInMinutes);
    }

    return new JwtSettings
    {
        SecretKey = Encoding.UTF8.GetBytes(secret),
        Issuer = issuer,
        Audience = audience,
        ExpiryInMinutes = expiryInMinutes
    };
}
```

## üß™ Testabilidade

### Unit Tests Essenciais
```csharp
[Test]
public async Task GenerateJwtTokenAsync_ValidUser_ReturnsSuccessWithValidToken()
{
    // Arrange: Mock user v√°lido
    // Act: Gerar token
    // Assert: Result.IsSuccess = true, token v√°lido
}

[Test]
public async Task GenerateJwtTokenAsync_NullUser_ReturnsFailure()
{
    // Arrange: User null
    // Act: Tentar gerar token
    // Assert: Result.IsSuccess = false, Error = "User cannot be null"
}

[Test]
public async Task ValidateTokenAsync_ExpiredToken_ReturnsTokenExpiredError()
{
    // Arrange: Token expirado
    // Act: Validar token
    // Assert: Result.IsSuccess = false, Error = "Token has expired"
}
```

### Integration Tests
```csharp
[Test]
public async Task TokenLifecycle_GenerateValidateExtractClaims_WorksEndToEnd()
{
    // Teste completo do ciclo de vida
    // 1. Gerar token
    // 2. Validar token
    // 3. Extrair claims
    // 4. Verificar dados
}
```

### Mocking Strategy
```csharp
// Mock IConfiguration para testes
var configurationMock = new Mock<IConfiguration>();
configurationMock.SetupGet(x => x["JwtSettings:Secret"]).Returns("test-secret-key");

// Mock ILogger para verificar logs
var loggerMock = new Mock<ILogger<TokenService>>();
```

## üìö Melhorias Implementadas

### Antes da Refatora√ß√£o
- Classe simples com 2 m√©todos
- Configura√ß√£o hard-coded inline
- Sem logging ou observabilidade
- Tratamento de erro via exce√ß√µes
- Opera√ß√µes s√≠ncronas apenas
- Sem valida√ß√µes de entrada
- Sem suporte a refresh tokens

### Ap√≥s a Refatora√ß√£o
- ‚úÖ **Servi√ßo enterprise completo** com 8+ m√©todos p√∫blicos
- ‚úÖ **Configura√ß√£o lazy-loaded** com valida√ß√£o rigorosa
- ‚úÖ **Logging estruturado** em todos os n√≠veis (Debug, Info, Warning, Error)
- ‚úÖ **Result pattern** para controle consistente de erro
- ‚úÖ **Opera√ß√µes ass√≠ncronas** com CancellationToken support
- ‚úÖ **Valida√ß√µes robustas** de entrada e formato
- ‚úÖ **Refresh token support** criptograficamente seguro
- ‚úÖ **Multi-tenancy avan√ßado** com extra√ß√£o de tenant claims
- ‚úÖ **Legacy compatibility** com m√©todos obsoletos
- ‚úÖ **Claims management** padronizado e extens√≠vel
- ‚úÖ **Security validations** com algoritmo binding
- ‚úÖ **Performance optimizations** com lazy loading e reuse
- ‚úÖ **Comprehensive documentation** XML e inline
- ‚úÖ **Enterprise error handling** com logging detalhado
- ‚úÖ **Testability** com dependency injection e abstra√ß√µes

## üéØ Cen√°rios de Uso Avan√ßados

### Authentication & Authorization
```csharp
// Login flow
var tokenResult = await tokenService.GenerateJwtTokenAsync(authenticatedUser);

// API request authorization
var principalResult = await tokenService.ValidateTokenAsync(bearerToken);

// Multi-tenant context extraction
var tenantResult = await tokenService.GetTenantIdFromTokenAsync(bearerToken);
```

### Token Refresh Flow
```csharp
// Extract user from expired token
var expiredPrincipalResult = await tokenService.GetPrincipalFromExpiredTokenAsync(expiredToken);

// Generate new tokens
var newTokenResult = await tokenService.GenerateJwtTokenAsync(refreshedUser);
var newRefreshResult = await tokenService.GenerateRefreshTokenAsync();
```

### Microservices Communication
```csharp
// Service-to-service token validation
var validationResult = await tokenService.ValidateTokenAsync(incomingToken);

// User context extraction for business logic
var userIdResult = await tokenService.GetUserIdFromTokenAsync(incomingToken);
```

Esta implementa√ß√£o representa um servi√ßo JWT enterprise-ready, otimizado para alta performance, seguran√ßa robusta e observabilidade completa em sistemas de produ√ß√£o multi-tenant.
