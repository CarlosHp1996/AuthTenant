# ITenantEntity.cs - Documentação Técnica

## Visão Geral
**Localização**: `AuthTenant.Domain/Interfaces/ITenantEntity.cs`
**Tipo**: Interface de Entidade de Domínio
**Propósito**: Define o contrato para entidades que pertencem a um tenant específico em sistemas multi-tenant.

## Responsabilidades
- Definir propriedade obrigatória de tenant
- Fornecer validação de associação de tenant
- Implementar métodos de verificação e controle
- Suportar migração entre tenants
- Manter histórico de associações de tenant

## Estrutura da Interface

### Propriedade Principal
```csharp
string TenantId { get; set; }                  // ID do tenant proprietário
```

### Métodos de Validação
```csharp
bool BelongsToTenant(string tenantId)          // Verifica se pertence ao tenant
bool HasValidTenantId()                        // Valida se TenantId é válido
```

### Métodos de Controle
```csharp
void SetTenantId(string tenantId)              // Define o tenant com validação
void MigrateToTenant(string newTenantId, string reason) // Migra para outro tenant
```

### Histórico e Auditoria
```csharp
IEnumerable<ITenantHistory> GetTenantHistory() // Histórico de associações
```

## Interfaces Auxiliares

### **ITenantAwareEntity**
```csharp
public interface ITenantAwareEntity : ITenantEntity
{
    bool IsSharedAcrosstenants { get; }        // Se é compartilhada entre tenants
    IEnumerable<string> AllowedTenants { get; } // Tenants com acesso permitido
    DateTime TenantAssignedAt { get; set; }     // Quando foi associada ao tenant
    string? TenantAssignedBy { get; set; }      // Quem fez a associação
}
```

### **ITenantHistory**
```csharp
public interface ITenantHistory
{
    string FromTenantId { get; set; }           // Tenant anterior
    string ToTenantId { get; set; }             // Tenant atual
    DateTime MigratedAt { get; set; }           // Data da migração
    string? MigratedBy { get; set; }            // Usuário responsável
    string? Reason { get; set; }                // Motivo da migração
    TenantMigrationType Type { get; set; }      // Tipo de migração
}
```

### **ITenantValidation**
```csharp
public interface ITenantValidation
{
    bool IsValidTenantId(string tenantId);      // Valida formato do ID
    bool CanAssignToTenant(string tenantId);    // Verifica se pode associar
    bool CanMigrateToTenant(string fromId, string toId); // Verifica migração
    IEnumerable<string> GetValidationErrors(string tenantId); // Erros de validação
}
```

## Enums Auxiliares

### **TenantMigrationType**
```csharp
public enum TenantMigrationType
{
    Manual,         // Migração manual
    Automatic,      // Migração automática
    Merge,          // Fusão de tenants
    Split,          // Divisão de tenant
    Acquisition,    // Aquisição de tenant
    Decommission   // Descomissionamento
}
```

### **TenantAssignmentStatus**
```csharp
public enum TenantAssignmentStatus
{
    Active,         // Associação ativa
    Pending,        // Pendente de ativação
    Migrating,      // Em processo de migração
    Suspended,      // Associação suspensa
    Archived        // Associação arquivada
}
```

## Padrões Implementados

### 1. **Multi-Tenancy**
- Isolamento de dados por tenant
- Validação automática de associação
- Controle de acesso baseado em tenant
- Auditoria de mudanças de tenant

### 2. **Domain Validation**
- Validação de regras de negócio
- Consistência de dados
- Prevenção de estados inválidos
- Mensagens de erro específicas

### 3. **Audit Trail**
- Histórico completo de associações
- Rastreamento de mudanças
- Identificação de responsáveis
- Compliance e governança

### 4. **Strategy Pattern**
- Diferentes tipos de migração
- Validações específicas por contexto
- Flexibilidade de implementação
- Extensibilidade futura

## Implementação Recomendada

### **Classe Base**
```csharp
public abstract class TenantEntityBase : ITenantEntity, ITenantAwareEntity, ITenantValidation
{
    private string _tenantId = string.Empty;
    private readonly List<ITenantHistory> _tenantHistory = new();

    public string TenantId 
    { 
        get => _tenantId; 
        set => SetTenantId(value); 
    }

    public DateTime TenantAssignedAt { get; set; } = DateTime.UtcNow;
    public string? TenantAssignedBy { get; set; }
    public virtual bool IsSharedAcrosstenants => false;
    public virtual IEnumerable<string> AllowedTenants => new[] { TenantId };

    public bool BelongsToTenant(string tenantId)
    {
        if (string.IsNullOrWhiteSpace(tenantId))
            return false;

        return TenantId.Equals(tenantId, StringComparison.OrdinalIgnoreCase) ||
               (IsSharedAcrosstenants && AllowedTenants.Contains(tenantId));
    }

    public bool HasValidTenantId()
    {
        return IsValidTenantId(TenantId) && !GetValidationErrors(TenantId).Any();
    }

    public void SetTenantId(string tenantId)
    {
        if (string.IsNullOrWhiteSpace(tenantId))
            throw new ArgumentException("TenantId não pode ser vazio", nameof(tenantId));

        if (!IsValidTenantId(tenantId))
            throw new ArgumentException($"TenantId '{tenantId}' tem formato inválido", nameof(tenantId));

        if (!CanAssignToTenant(tenantId))
            throw new InvalidOperationException($"Não é possível associar ao tenant '{tenantId}'");

        var oldTenantId = _tenantId;
        _tenantId = tenantId;

        if (!string.IsNullOrEmpty(oldTenantId) && oldTenantId != tenantId)
        {
            AddTenantHistory(oldTenantId, tenantId, "SetTenantId", TenantMigrationType.Manual);
        }

        TenantAssignedAt = DateTime.UtcNow;
    }

    public void MigrateToTenant(string newTenantId, string reason)
    {
        if (string.IsNullOrWhiteSpace(newTenantId))
            throw new ArgumentException("Novo TenantId não pode ser vazio", nameof(newTenantId));

        if (!CanMigrateToTenant(TenantId, newTenantId))
            throw new InvalidOperationException($"Migração de '{TenantId}' para '{newTenantId}' não é permitida");

        var oldTenantId = TenantId;
        _tenantId = newTenantId;
        TenantAssignedAt = DateTime.UtcNow;

        AddTenantHistory(oldTenantId, newTenantId, reason, TenantMigrationType.Manual);
    }

    public IEnumerable<ITenantHistory> GetTenantHistory()
    {
        return _tenantHistory.AsReadOnly();
    }

    // Implementação dos métodos de validação...
}
```

### **Configuração Entity Framework**
```csharp
public class TenantEntityConfiguration<T> : IEntityTypeConfiguration<T> where T : class, ITenantEntity
{
    public void Configure(EntityTypeBuilder<T> builder)
    {
        builder.Property(e => e.TenantId)
            .IsRequired()
            .HasMaxLength(50)
            .HasColumnName("TenantId");

        builder.HasIndex(e => e.TenantId)
            .HasDatabaseName($"IX_{typeof(T).Name}_TenantId");

        // Global query filter para isolamento automático
        builder.HasQueryFilter(e => e.TenantId == GetCurrentTenantId());
    }

    private string GetCurrentTenantId()
    {
        // Obter do contexto atual (ICurrentTenantService)
        return "current-tenant-id";
    }
}
```

## Cenários de Uso

### **1. Criação de Entidade**
```csharp
public class Product : TenantEntityBase
{
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    
    public Product(string tenantId)
    {
        SetTenantId(tenantId);
    }
}

// Uso
var product = new Product(currentTenantService.CurrentTenantId);
```

### **2. Validação de Acesso**
```csharp
public async Task<Product> GetProductAsync(int productId)
{
    var product = await repository.GetByIdAsync(productId);
    
    if (product != null && !product.BelongsToTenant(currentTenantService.CurrentTenantId))
    {
        throw new UnauthorizedTenantAccessException($"Produto {productId} não pertence ao tenant atual");
    }
    
    return product;
}
```

### **3. Migração de Tenant**
```csharp
public async Task MigrateProductsToNewTenant(IEnumerable<int> productIds, string newTenantId, string reason)
{
    var products = await repository.GetManyAsync(p => productIds.Contains(p.Id));
    
    foreach (var product in products)
    {
        if (product.CanMigrateToTenant(product.TenantId, newTenantId))
        {
            product.MigrateToTenant(newTenantId, reason);
        }
    }
    
    await repository.SaveChangesAsync();
}
```

### **4. Auditoria de Tenant**
```csharp
public async Task<IEnumerable<TenantMigrationReport>> GetTenantMigrationHistoryAsync(string tenantId)
{
    var entities = await repository.GetManyAsync(e => e.TenantId == tenantId);
    
    return entities.SelectMany(e => e.GetTenantHistory())
                  .Select(h => new TenantMigrationReport
                  {
                      EntityType = e.GetType().Name,
                      FromTenant = h.FromTenantId,
                      ToTenant = h.ToTenantId,
                      MigratedAt = h.MigratedAt,
                      Reason = h.Reason
                  });
}
```

## Integração com EF Core

### **Global Query Filters**
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    // Aplicar filtro global para todas as entidades tenant
    foreach (var entityType in modelBuilder.Model.GetEntityTypes())
    {
        if (typeof(ITenantEntity).IsAssignableFrom(entityType.ClrType))
        {
            var parameter = Expression.Parameter(entityType.ClrType, "e");
            var property = Expression.Property(parameter, nameof(ITenantEntity.TenantId));
            var currentTenant = Expression.Constant(_tenantService.CurrentTenantId);
            var equal = Expression.Equal(property, currentTenant);
            var lambda = Expression.Lambda(equal, parameter);

            modelBuilder.Entity(entityType.ClrType).HasQueryFilter(lambda);
        }
    }
}
```

### **Interceptação Automática**
```csharp
public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    foreach (var entry in ChangeTracker.Entries<ITenantEntity>())
    {
        if (entry.State == EntityState.Added && string.IsNullOrEmpty(entry.Entity.TenantId))
        {
            entry.Entity.SetTenantId(_tenantService.CurrentTenantId);
        }
    }
    
    return base.SaveChangesAsync(cancellationToken);
}
```

## Validações Avançadas

### **Validação de Formato**
```csharp
public bool IsValidTenantId(string tenantId)
{
    if (string.IsNullOrWhiteSpace(tenantId))
        return false;

    // Formato: tenant-{guid} ou empresa-slug
    var guidPattern = @"^tenant-[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$";
    var slugPattern = @"^[a-z0-9]+(?:-[a-z0-9]+)*$";

    return Regex.IsMatch(tenantId, guidPattern) || 
           (tenantId.Length >= 3 && tenantId.Length <= 50 && Regex.IsMatch(tenantId, slugPattern));
}
```

### **Validação de Regras de Negócio**
```csharp
public IEnumerable<string> GetValidationErrors(string tenantId)
{
    var errors = new List<string>();

    if (!IsValidTenantId(tenantId))
        errors.Add("Formato de TenantId inválido");

    if (IsReservedTenantId(tenantId))
        errors.Add("TenantId é reservado pelo sistema");

    if (!_tenantService.TenantExists(tenantId))
        errors.Add("Tenant não existe ou está inativo");

    return errors;
}
```

## Segurança e Compliance

### **Prevenção de Cross-Tenant Access**
```csharp
public class TenantSecurityMiddleware
{
    public async Task InvokeAsync(HttpContext context, ICurrentTenantService tenantService)
    {
        var requestedTenantId = ExtractTenantFromRequest(context);
        
        if (!string.IsNullOrEmpty(requestedTenantId))
        {
            if (!await tenantService.HasAccessToTenantAsync(requestedTenantId))
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsync("Acesso negado ao tenant especificado");
                return;
            }
            
            await tenantService.SetTenantAsync(requestedTenantId);
        }
        
        await _next(context);
    }
}
```

### **Auditoria de Acesso**
```csharp
public class TenantAccessAuditInterceptor : IInterceptor
{
    public void Intercept(IInvocation invocation)
    {
        if (invocation.Method.Name.StartsWith("Get") && 
            invocation.ReturnValue is ITenantEntity entity)
        {
            _auditService.LogTenantAccess(new TenantAccessLog
            {
                UserId = _userService.CurrentUserId,
                TenantId = entity.TenantId,
                EntityType = entity.GetType().Name,
                AccessedAt = DateTime.UtcNow,
                Action = invocation.Method.Name
            });
        }
        
        invocation.Proceed();
    }
}
```

## Performance e Otimização

### **Índices Recomendados**
```sql
-- Índice principal por tenant
CREATE INDEX IX_Products_TenantId ON Products (TenantId);

-- Índice composto para consultas frequentes
CREATE INDEX IX_Products_TenantId_IsActive ON Products (TenantId, IsActive);

-- Índice para histórico de migração
CREATE INDEX IX_TenantHistory_FromTenantId ON TenantHistory (FromTenantId);
CREATE INDEX IX_TenantHistory_ToTenantId ON TenantHistory (ToTenantId);
```

### **Cache de Validação**
```csharp
private readonly IMemoryCache _validationCache;

public bool CanAssignToTenant(string tenantId)
{
    var cacheKey = $"tenant_validation_{tenantId}";
    
    return _validationCache.GetOrCreate(cacheKey, entry =>
    {
        entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30);
        return ValidateTenantAssignment(tenantId);
    });
}
```

## Monitoramento e Alertas

### **Métricas de Tenant**
```csharp
public class TenantMetricsCollector
{
    public void RecordTenantMigration(string fromTenantId, string toTenantId, string entityType)
    {
        _metrics.Counter("tenant_migrations_total")
            .WithTag("from_tenant", fromTenantId)
            .WithTag("to_tenant", toTenantId)
            .WithTag("entity_type", entityType)
            .Increment();
    }

    public void RecordTenantAccessViolation(string userId, string attemptedTenantId)
    {
        _metrics.Counter("tenant_access_violations_total")
            .WithTag("user_id", userId)
            .WithTag("attempted_tenant", attemptedTenantId)
            .Increment();

        _alerting.SendAlert(new SecurityAlert
        {
            Type = "TenantAccessViolation",
            UserId = userId,
            AttemptedTenantId = attemptedTenantId,
            Timestamp = DateTime.UtcNow
        });
    }
}
```

## Melhorias Implementadas na Refatoração

### **Funcionalidades Adicionadas**
1. **Validação Rica**: IsValidTenantId, GetValidationErrors para validação completa
2. **Histórico**: GetTenantHistory para auditoria completa
3. **Migração**: MigrateToTenant com razão e tipo
4. **Controle Avançado**: CanAssignToTenant, CanMigrateToTenant
5. **Interfaces Auxiliares**: ITenantAwareEntity, ITenantHistory, ITenantValidation

### **Padrões Aplicados**
1. **Domain Validation**: Validação no domínio
2. **Audit Trail**: Histórico completo de mudanças
3. **Strategy Pattern**: Diferentes tipos de migração
4. **Template Method**: Estrutura extensível

### **Melhorias de Segurança**
1. **Cross-Tenant Protection**: Validação rigorosa
2. **Audit Logging**: Rastreamento completo
3. **Access Control**: Verificação de permissões
4. **Data Isolation**: Isolamento garantido

## Roadmap de Evolução

### **Próximas Funcionalidades**
1. **Multi-Database**: Suporte a databases separados
2. **Soft Migration**: Migração gradual entre tenants
3. **Backup Seletivo**: Backup por tenant
4. **Data Encryption**: Criptografia por tenant

### **Integrações Futuras**
1. **Event Sourcing**: Eventos de migração
2. **CQRS**: Separação de comandos e consultas
3. **Message Queues**: Migração assíncrona
4. **Analytics**: Análise de uso por tenant

## Conclusão

A interface `ITenantEntity` é fundamental para implementação segura e eficiente de multi-tenancy, fornecendo isolamento robusto, auditoria completa e flexibilidade para migrações. A refatoração implementou padrões avançados de segurança, validação e extensibilidade, garantindo uma base sólida para crescimento e evolução do sistema.
