# ITenantRepository.cs - Documentação Técnica

## Visão Geral
**Localização**: `AuthTenant.Domain/Interfaces/ITenantRepository.cs`
**Tipo**: Interface de Repositório Especializado
**Propósito**: Define operações específicas para gerenciamento de tenants em sistemas multi-tenant, com foco em segurança, performance e administração.

## Responsabilidades
- Fornecer operações CRUD especializadas para tenants
- Implementar validações específicas de tenant
- Gerenciar cache inteligente para performance
- Suportar operações administrativas em lote
- Fornecer métricas e estatísticas de uso
- Controlar ativação/desativação de tenants

## Estrutura da Interface

### Operações de Consulta Básicas
```csharp
Task<Tenant?> GetByIdAsync(string tenantId, ...)              // Busca por ID
Task<Tenant?> GetByNameAsync(string name, ...)               // Busca por nome
Task<Tenant?> GetByDomainAsync(string domain, ...)           // Busca por domínio
Task<Tenant?> GetByApiKeyAsync(string apiKey, ...)           // Busca por API key
Task<Tenant?> GetWithDetailsAsync(string tenantId, ...)      // Com dados completos
```

### Consultas de Listagem
```csharp
Task<IEnumerable<Tenant>> GetAllActiveAsync(...)             // Todos ativos
Task<IPagedResult<Tenant>> GetPagedAsync(...)                // Paginação avançada
Task<IEnumerable<Tenant>> SearchAsync(...)                   // Busca por critérios
Task<IEnumerable<Tenant>> GetTenantsRequiringAttentionAsync(...) // Precisam atenção
Task<IEnumerable<Tenant>> GetBySubscriptionPlanAsync(...)    // Por plano
```

### Operações de Comando
```csharp
Task<Tenant> CreateAsync(Tenant tenant, ...)                 // Cria com validação
Task UpdateAsync(Tenant tenant, ...)                         // Atualiza com validação
Task<bool> UpdateFieldsAsync(...)                            // Atualização parcial
```

### Controle de Estado
```csharp
Task<bool> ActivateAsync(string tenantId, ...)               // Ativa tenant
Task<bool> DeactivateAsync(string tenantId, ...)             // Desativa tenant
Task<bool> SoftDeleteAsync(string tenantId, ...)             // Remove (soft)
Task<bool> RestoreAsync(string tenantId, ...)                // Restaura removido
```

### Validações e Verificações
```csharp
Task<bool> ExistsAsync(string tenantId, ...)                 // Verifica existência
Task<bool> ExistsByNameAsync(string name, ...)               // Por nome
Task<bool> ExistsByDomainAsync(string domain, ...)           // Por domínio
Task<int> CountAsync(...)                                    // Conta tenants
```

### Métricas e Administração
```csharp
Task<ITenantStatistics> GetStatisticsAsync(...)              // Estatísticas
Task UpdateUsageMetricsAsync(...)                            // Atualiza métricas
Task InvalidateCacheAsync(...)                               // Limpa cache
Task<IDictionary<string, bool>> ExecuteBatchOperationAsync(...) // Operações em lote
```

## Interfaces Auxiliares

### **ITenantSearchCriteria**
```csharp
public interface ITenantSearchCriteria
{
    string? SearchTerm { get; set; }                // Termo de busca
    TenantStatus? Status { get; set; }              // Filtro por status
    string? SubscriptionPlan { get; set; }          // Filtro por plano
    DateTime? CreatedAfter { get; set; }            // Criados após data
    DateTime? CreatedBefore { get; set; }           // Criados antes data
    bool? IsActive { get; set; }                    // Filtro ativo/inativo
    int? MinUsers { get; set; }                     // Mínimo de usuários
    int? MaxUsers { get; set; }                     // Máximo de usuários
    IEnumerable<string>? Tags { get; set; }         // Filtro por tags
}
```

### **ITenantStatistics**
```csharp
public interface ITenantStatistics
{
    int TotalTenants { get; set; }                  // Total de tenants
    int ActiveTenants { get; set; }                 // Tenants ativos
    int TrialTenants { get; set; }                  // Em trial
    int ExpiredTenants { get; set; }                // Expirados
    Dictionary<string, int> TenantsByPlan { get; set; }    // Por plano
    Dictionary<string, int> TenantsByRegion { get; set; }  // Por região
    double AverageUsersPerTenant { get; set; }      // Média de usuários
    DateTime GeneratedAt { get; set; }              // Data geração
}
```

### **ITenantUsageMetrics**
```csharp
public interface ITenantUsageMetrics
{
    string TenantId { get; set; }                   // ID do tenant
    int CurrentUsers { get; set; }                  // Usuários ativos
    long CurrentStorage { get; set; }               // Storage usado
    int CurrentProducts { get; set; }               // Produtos cadastrados
    int CurrentApiCalls { get; set; }               // Chamadas API
    DateTime LastActivity { get; set; }             // Última atividade
    DateTime MeasuredAt { get; set; }               // Data da medição
}
```

## Enums de Suporte

### **TenantStatus**
```csharp
public enum TenantStatus
{
    Active,         // Ativo e operacional
    Inactive,       // Inativo ou suspenso
    Trial,          // Em período trial
    Expired,        // Assinatura expirada
    Deleted         // Removido (soft delete)
}
```

### **TenantOrderBy**
```csharp
public enum TenantOrderBy
{
    Name,           // Por nome
    CreatedAt,      // Por data criação
    LastActivity,   // Por última atividade
    SubscriptionPlan, // Por plano
    Status,         // Por status
    UserCount       // Por número usuários
}
```

## Implementação Recomendada

### **Classe Base do Repository**
```csharp
public class TenantRepository : ITenantRepository
{
    private readonly DbContext _context;
    private readonly IMemoryCache _cache;
    private readonly ILogger<TenantRepository> _logger;
    private readonly ITenantValidator _validator;

    public TenantRepository(
        DbContext context,
        IMemoryCache cache,
        ILogger<TenantRepository> logger,
        ITenantValidator validator)
    {
        _context = context;
        _cache = cache;
        _logger = logger;
        _validator = validator;
    }

    public async Task<Tenant?> GetByIdAsync(
        string tenantId, 
        CancellationToken cancellationToken = default,
        bool includeDeleted = false,
        bool useCache = true)
    {
        if (string.IsNullOrWhiteSpace(tenantId))
            return null;

        if (useCache)
        {
            var cacheKey = $"tenant_{tenantId}_{includeDeleted}";
            if (_cache.TryGetValue(cacheKey, out Tenant? cachedTenant))
            {
                return cachedTenant;
            }
        }

        var query = _context.Set<Tenant>().AsQueryable();

        if (!includeDeleted)
        {
            query = query.Where(t => !t.IsDeleted);
        }

        var tenant = await query
            .FirstOrDefaultAsync(t => t.Id == tenantId, cancellationToken);

        if (tenant != null && useCache)
        {
            var cacheKey = $"tenant_{tenantId}_{includeDeleted}";
            _cache.Set(cacheKey, tenant, TimeSpan.FromMinutes(30));
        }

        return tenant;
    }

    // Implementação dos demais métodos...
}
```

### **Configuração de DI**
```csharp
services.AddScoped<ITenantRepository, TenantRepository>();
services.AddScoped<ITenantValidator, TenantValidator>();
services.AddMemoryCache();
```

## Cenários de Uso Avançados

### **1. Criação de Tenant com Inicialização**
```csharp
public async Task<Tenant> CreateTenantWithSetupAsync(CreateTenantRequest request)
{
    var tenant = new Tenant
    {
        Id = GenerateTenantId(),
        Name = request.Name,
        Domain = request.Domain,
        SubscriptionPlan = request.Plan,
        ApiKey = GenerateApiKey(),
        CreatedAt = DateTime.UtcNow,
        Status = TenantStatus.Active
    };

    // Criar com configurações padrão
    var createdTenant = await _tenantRepository.CreateAsync(tenant, initializeDefaults: true);

    // Configurar database específico
    await SetupTenantDatabaseAsync(createdTenant.Id);

    // Criar usuário administrador
    await CreateTenantAdminUserAsync(createdTenant.Id, request.AdminEmail);

    _logger.LogInformation("Tenant {TenantId} criado com sucesso", createdTenant.Id);

    return createdTenant;
}
```

### **2. Busca Avançada com Múltiplos Critérios**
```csharp
public async Task<IEnumerable<Tenant>> SearchTenantsAsync(TenantSearchRequest request)
{
    var criteria = new TenantSearchCriteria
    {
        SearchTerm = request.Query,
        Status = request.Status,
        SubscriptionPlan = request.Plan,
        CreatedAfter = request.DateFrom,
        CreatedBefore = request.DateTo,
        IsActive = request.ActiveOnly,
        MinUsers = request.MinUsers,
        MaxUsers = request.MaxUsers,
        Tags = request.Tags
    };

    var tenants = await _tenantRepository.SearchAsync(criteria);

    return tenants.OrderBy(t => t.Name);
}
```

### **3. Relatório de Saúde dos Tenants**
```csharp
public async Task<TenantHealthReport> GenerateHealthReportAsync()
{
    var statistics = await _tenantRepository.GetStatisticsAsync();
    var attention = await _tenantRepository.GetTenantsRequiringAttentionAsync();

    return new TenantHealthReport
    {
        TotalTenants = statistics.TotalTenants,
        ActiveTenants = statistics.ActiveTenants,
        TenantsNeedingAttention = attention.Count(),
        TopIssues = IdentifyTopIssues(attention),
        DistributionByPlan = statistics.TenantsByPlan,
        GeneratedAt = DateTime.UtcNow
    };
}
```

### **4. Migração em Lote**
```csharp
public async Task<BatchOperationResult> MigrateTenantsToNewPlanAsync(
    IEnumerable<string> tenantIds, 
    string newPlan,
    string reason)
{
    var operation = async (Tenant tenant) =>
    {
        try
        {
            tenant.SubscriptionPlan = newPlan;
            tenant.UpdatedAt = DateTime.UtcNow;
            await _tenantRepository.UpdateAsync(tenant, validateChanges: true);

            await _auditService.LogTenantChangeAsync(tenant.Id, "PlanMigration", reason);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erro ao migrar tenant {TenantId} para plano {Plan}", tenant.Id, newPlan);
            return false;
        }
    };

    var results = await _tenantRepository.ExecuteBatchOperationAsync(tenantIds, operation);

    return new BatchOperationResult
    {
        TotalProcessed = results.Count,
        Successful = results.Values.Count(v => v),
        Failed = results.Values.Count(v => !v),
        Details = results
    };
}
```

## Cache Inteligente

### **Estratégia de Cache Multi-Layer**
```csharp
public class TenantCacheService
{
    private readonly IMemoryCache _l1Cache;
    private readonly IDistributedCache _l2Cache;

    public async Task<Tenant?> GetTenantAsync(string tenantId)
    {
        // L1 Cache (in-memory)
        if (_l1Cache.TryGetValue($"tenant_{tenantId}", out Tenant? tenant))
        {
            return tenant;
        }

        // L2 Cache (Redis)
        var cachedData = await _l2Cache.GetStringAsync($"tenant_{tenantId}");
        if (!string.IsNullOrEmpty(cachedData))
        {
            tenant = JsonSerializer.Deserialize<Tenant>(cachedData);
            _l1Cache.Set($"tenant_{tenantId}", tenant, TimeSpan.FromMinutes(10));
            return tenant;
        }

        // Database
        tenant = await LoadFromDatabaseAsync(tenantId);
        if (tenant != null)
        {
            await CacheTenantAsync(tenant);
        }

        return tenant;
    }

    private async Task CacheTenantAsync(Tenant tenant)
    {
        var serialized = JsonSerializer.Serialize(tenant);

        // Cache em ambos os níveis
        _l1Cache.Set($"tenant_{tenant.Id}", tenant, TimeSpan.FromMinutes(10));
        await _l2Cache.SetStringAsync($"tenant_{tenant.Id}", serialized, new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)
        });
    }
}
```

### **Invalidação Inteligente**
```csharp
public async Task InvalidateTenantCacheAsync(string tenantId)
{
    // Remover do cache local
    _l1Cache.Remove($"tenant_{tenantId}");

    // Remover do cache distribuído
    await _l2Cache.RemoveAsync($"tenant_{tenantId}");

    // Notificar outras instâncias via message bus
    await _messageBus.PublishAsync(new TenantCacheInvalidatedEvent { TenantId = tenantId });

    _logger.LogInformation("Cache invalidado para tenant {TenantId}", tenantId);
}
```

## Validações Avançadas

### **Validação de Criação de Tenant**
```csharp
public async Task<ValidationResult> ValidateCreateTenantAsync(Tenant tenant)
{
    var result = new ValidationResult();

    // Validar unicidade do nome
    if (await ExistsByNameAsync(tenant.Name))
    {
        result.AddError("Name", "Já existe um tenant com este nome");
    }

    // Validar domínio customizado
    if (!string.IsNullOrEmpty(tenant.CustomDomain))
    {
        if (await ExistsByDomainAsync(tenant.CustomDomain))
        {
            result.AddError("CustomDomain", "Domínio já está em uso");
        }

        if (!IsValidDomain(tenant.CustomDomain))
        {
            result.AddError("CustomDomain", "Formato de domínio inválido");
        }
    }

    // Validar plano de assinatura
    if (!IsValidSubscriptionPlan(tenant.SubscriptionPlan))
    {
        result.AddError("SubscriptionPlan", "Plano de assinatura inválido");
    }

    // Validar limites do sistema
    var currentCount = await CountAsync(activeOnly: true);
    if (currentCount >= GetMaxTenants())
    {
        result.AddError("System", "Limite máximo de tenants atingido");
    }

    return result;
}
```

### **Validação de Atualização**
```csharp
public async Task<ValidationResult> ValidateUpdateTenantAsync(Tenant tenant)
{
    var result = new ValidationResult();
    var existing = await GetByIdAsync(tenant.Id);

    if (existing == null)
    {
        result.AddError("Id", "Tenant não encontrado");
        return result;
    }

    // Validar mudanças críticas
    if (existing.SubscriptionPlan != tenant.SubscriptionPlan)
    {
        if (!CanUpgradeToSubscriptionPlan(existing.SubscriptionPlan, tenant.SubscriptionPlan))
        {
            result.AddError("SubscriptionPlan", "Upgrade de plano não permitido");
        }
    }

    // Validar mudança de domínio
    if (existing.CustomDomain != tenant.CustomDomain && 
        !string.IsNullOrEmpty(tenant.CustomDomain))
    {
        if (await ExistsByDomainAsync(tenant.CustomDomain, tenant.Id))
        {
            result.AddError("CustomDomain", "Domínio já está em uso por outro tenant");
        }
    }

    return result;
}
```

## Métricas e Monitoramento

### **Coleta de Métricas de Usage**
```csharp
public async Task UpdateTenantUsageMetricsAsync(string tenantId)
{
    var metrics = new TenantUsageMetrics
    {
        TenantId = tenantId,
        CurrentUsers = await CountActiveUsersAsync(tenantId),
        CurrentStorage = await CalculateStorageUsageAsync(tenantId),
        CurrentProducts = await CountProductsAsync(tenantId),
        CurrentApiCalls = await CountTodayApiCallsAsync(tenantId),
        LastActivity = await GetLastActivityAsync(tenantId),
        MeasuredAt = DateTime.UtcNow
    };

    await _tenantRepository.UpdateUsageMetricsAsync(tenantId, metrics);

    // Verificar limites e alertas
    await CheckUsageLimitsAsync(tenantId, metrics);
}

private async Task CheckUsageLimitsAsync(string tenantId, ITenantUsageMetrics metrics)
{
    var tenant = await GetByIdAsync(tenantId);
    var limits = GetPlanLimits(tenant.SubscriptionPlan);

    if (metrics.CurrentUsers > limits.MaxUsers * 0.9) // 90% do limite
    {
        await _alertService.SendUsageAlertAsync(tenantId, "Users", metrics.CurrentUsers, limits.MaxUsers);
    }

    if (metrics.CurrentStorage > limits.MaxStorage * 0.9)
    {
        await _alertService.SendUsageAlertAsync(tenantId, "Storage", metrics.CurrentStorage, limits.MaxStorage);
    }
}
```

### **Dashboard de Administração**
```csharp
public async Task<TenantDashboardData> GetDashboardDataAsync()
{
    var statistics = await GetStatisticsAsync();
    var recentActivity = await GetRecentTenantActivityAsync(TimeSpan.FromDays(7));
    var topTenants = await GetTopTenantsByUsageAsync(10);
    var alerts = await GetActiveAlertsAsync();

    return new TenantDashboardData
    {
        Statistics = statistics,
        RecentActivity = recentActivity,
        TopTenants = topTenants,
        ActiveAlerts = alerts,
        HealthScore = CalculateSystemHealthScore(statistics),
        GeneratedAt = DateTime.UtcNow
    };
}
```

## Backup e Recuperação

### **Backup por Tenant**
```csharp
public async Task<BackupResult> BackupTenantDataAsync(string tenantId, BackupOptions options)
{
    try
    {
        var tenant = await GetByIdAsync(tenantId);
        if (tenant == null)
            throw new TenantNotFoundException(tenantId);

        var backupPath = GenerateBackupPath(tenantId, DateTime.UtcNow);

        // Backup dos dados principais
        await BackupTenantDatabaseAsync(tenantId, backupPath, options);

        // Backup de arquivos/storage
        if (options.IncludeFiles)
        {
            await BackupTenantFilesAsync(tenantId, backupPath);
        }

        // Backup de configurações
        await BackupTenantConfigurationAsync(tenantId, backupPath);

        var backupInfo = new TenantBackup
        {
            TenantId = tenantId,
            BackupPath = backupPath,
            CreatedAt = DateTime.UtcNow,
            Size = CalculateBackupSize(backupPath),
            Type = options.Type
        };

        await SaveBackupInfoAsync(backupInfo);

        return new BackupResult { Success = true, BackupInfo = backupInfo };
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Erro ao fazer backup do tenant {TenantId}", tenantId);
        return new BackupResult { Success = false, Error = ex.Message };
    }
}
```

## Melhorias Implementadas na Refatoração

### **Funcionalidades Adicionadas**
1. **Cache Inteligente**: Multi-layer com invalidação automática
2. **Busca Avançada**: TenantSearchCriteria com múltiplos filtros
3. **Operações em Lote**: ExecuteBatchOperationAsync para administração
4. **Métricas**: ITenantStatistics e ITenantUsageMetrics
5. **Validações**: Validação rica de criação e atualização
6. **Estados**: Ativação, desativação, soft delete, restore
7. **API Keys**: Busca por chave API para autenticação

### **Padrões Aplicados**
1. **Repository Pattern**: Especializado para tenants
2. **Cache-Aside**: Cache inteligente com fallback
3. **Batch Processing**: Operações em lote eficientes
4. **Specification**: Critérios de busca flexíveis
5. **Command Query Separation**: Métodos claramente separados

### **Melhorias de Performance**
1. **Cache Multi-Layer**: L1 (memory) + L2 (Redis)
2. **Invalidação Inteligente**: Notificação distribuída
3. **Paginação Otimizada**: Com metadados ricos
4. **Bulk Operations**: Operações em lote
5. **Includes Seletivos**: Eager loading opcional

### **Melhorias de Administração**
1. **Dashboard Data**: Estatísticas administrativas
2. **Health Monitoring**: Tenants que precisam atenção
3. **Usage Metrics**: Monitoramento de uso
4. **Backup Support**: Backup por tenant individual
5. **Batch Operations**: Operações administrativas em massa

## Roadmap de Evolução

### **Próximas Funcionalidades**
1. **Multi-Database**: Suporte a databases separados por tenant
2. **Sharding**: Distribuição automática de tenants
3. **Auto-scaling**: Escalabilidade automática por tenant
4. **Advanced Analytics**: Métricas avançadas e insights

### **Integrações Futuras**
1. **Event Sourcing**: Eventos de tenant para auditoria
2. **Message Queues**: Operações assíncronas
3. **Kubernetes**: Deploy por tenant
4. **Observability**: Métricas distribuídas

## Conclusão

A interface `ITenantRepository` fornece uma base robusta e extensível para gerenciamento avançado de tenants, implementando padrões modernos de cache, validação, monitoramento e administração. A refatoração introduziu funcionalidades enterprise-grade, melhorou significativamente a performance e observabilidade, e criou uma fundação sólida para crescimento e evolução do sistema multi-tenant.
