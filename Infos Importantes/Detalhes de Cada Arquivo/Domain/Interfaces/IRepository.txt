# IRepository.cs - Documentação Técnica

## Visão Geral
**Localização**: `AuthTenant.Domain/Interfaces/IRepository.cs`
**Tipo**: Interface de Repositório Genérico
**Propósito**: Define o contrato padrão para operações de acesso a dados, implementando padrões Repository e Unit of Work.

## Responsabilidades
- Fornecer operações CRUD padronizadas e type-safe
- Implementar paginação e consultas avançadas
- Suportar includes para eager loading
- Gerenciar soft delete e auditoria
- Fornecer controle transacional
- Otimizar performance com tracking seletivo

## Estrutura da Interface

### Propriedades de Estado
```csharp
EntityState GetEntityState(TEntity entity)     // Estado atual da entidade
void SetEntityState(TEntity entity, EntityState state) // Define estado
bool HasUnsavedChanges { get; }                // Se há mudanças pendentes
```

### Operações de Consulta
```csharp
Task<TEntity?> GetByIdAsync(object id, ...)           // Busca por ID
Task<TEntity?> GetFirstAsync(Expression<Func<TEntity, bool>> predicate, ...)
Task<IEnumerable<TEntity>> GetAllAsync(...)           // Busca todas as entidades
Task<IEnumerable<TEntity>> GetManyAsync(Expression<Func<TEntity, bool>> predicate, ...)
```

### Paginação Avançada
```csharp
Task<IPagedResult<TEntity>> GetPagedAsync(int pageNumber, int pageSize, ...)
Task<IPagedResult<TProjection>> GetPagedProjectionAsync<TProjection>(...)
```

### Operações de Comando
```csharp
Task<TEntity> AddAsync(TEntity entity, ...)           // Adiciona entidade
Task AddRangeAsync(IEnumerable<TEntity> entities, ...) // Adiciona múltiplas
Task<TEntity> UpdateAsync(TEntity entity, ...)        // Atualiza entidade
Task UpdateRangeAsync(IEnumerable<TEntity> entities, ...)
```

### Soft Delete
```csharp
Task<bool> DeleteAsync(object id, ...)                // Soft delete por ID
Task<bool> DeleteAsync(TEntity entity, ...)           // Soft delete entidade
Task<int> DeleteManyAsync(Expression<Func<TEntity, bool>> predicate, ...)
Task<bool> RestoreAsync(object id, ...)               // Restaura soft deleted
```

### Operações de Verificação
```csharp
Task<bool> ExistsAsync(object id, ...)                // Verifica existência
Task<bool> ExistsAsync(Expression<Func<TEntity, bool>> predicate, ...)
Task<int> CountAsync(...)                             // Conta entidades
```

### Controle Transacional
```csharp
Task<IDbContextTransaction> BeginTransactionAsync(...)
Task SaveChangesAsync(...)                            // Salva mudanças
void DetachEntity(TEntity entity)                     // Remove do tracking
void AttachEntity(TEntity entity)                     // Adiciona ao tracking
```

## Interfaces Auxiliares

### **IPagedResult<T>**
```csharp
public interface IPagedResult<T>
{
    IEnumerable<T> Items { get; }
    int TotalCount { get; }
    int PageNumber { get; }
    int PageSize { get; }
    int TotalPages { get; }
    bool HasPreviousPage { get; }
    bool HasNextPage { get; }
    IDictionary<string, object> Metadata { get; }
}
```

### **ITransactionManager**
```csharp
public interface ITransactionManager
{
    Task<IDbContextTransaction> BeginTransactionAsync(IsolationLevel isolationLevel = IsolationLevel.ReadCommitted);
    Task CommitAsync();
    Task RollbackAsync();
    bool IsInTransaction { get; }
    IDbContextTransaction? CurrentTransaction { get; }
}
```

### **IRepositoryOptions**
```csharp
public interface IRepositoryOptions
{
    bool TrackChanges { get; set; }
    bool IncludeSoftDeleted { get; set; }
    int DefaultPageSize { get; set; }
    int MaxPageSize { get; set; }
    TimeSpan DefaultTimeout { get; set; }
}
```

## Padrões Implementados

### 1. **Repository Pattern**
- Abstração da camada de dados
- Operações padronizadas e consistentes
- Facilita testing e mocking
- Centraliza lógica de acesso a dados

### 2. **Unit of Work**
- Controle transacional
- Gerenciamento de mudanças
- SaveChanges coordenado
- Rollback automático em falhas

### 3. **Specification Pattern**
- Consultas complexas via Expression trees
- Reutilização de critérios de busca
- Composição de filtros
- Type-safe query building

### 4. **Pagination Pattern**
- Paginação eficiente e consistente
- Metadados ricos de navegação
- Suporte a projeções
- Otimização de memory usage

## Implementação Base Recomendada

### **Classe Base do Repository**
```csharp
public abstract class BaseRepository<TEntity> : IRepository<TEntity> 
    where TEntity : class
{
    protected readonly DbContext _context;
    protected readonly DbSet<TEntity> _dbSet;
    protected readonly ILogger _logger;

    public BaseRepository(DbContext context, ILogger logger)
    {
        _context = context;
        _dbSet = context.Set<TEntity>();
        _logger = logger;
    }

    public virtual async Task<TEntity?> GetByIdAsync(object id, 
        CancellationToken cancellationToken = default,
        bool includeDeleted = false,
        bool trackChanges = true,
        params Expression<Func<TEntity, object>>[] includes)
    {
        var query = BuildBaseQuery(includeDeleted, trackChanges);
        query = ApplyIncludes(query, includes);
        return await query.FirstOrDefaultAsync(e => EF.Property<object>(e, "Id").Equals(id), cancellationToken);
    }

    // Implementação dos demais métodos...
}
```

### **Configuração de DI**
```csharp
services.AddScoped(typeof(IRepository<>), typeof(BaseRepository<>));
services.AddScoped<IRepository<Product>, ProductRepository>();
services.AddScoped<IUnitOfWork, UnitOfWork>();
```

## Cenários de Uso Avançados

### **1. Consultas Complexas com Includes**
```csharp
var products = await repository.GetManyAsync(
    predicate: p => p.Category == "Electronics",
    includes: new[] { p => p.Category, p => p.Reviews },
    orderBy: p => p.Name,
    ascending: true,
    trackChanges: false
);
```

### **2. Paginação com Projeção**
```csharp
var pagedProducts = await repository.GetPagedProjectionAsync<ProductSummaryDto>(
    pageNumber: 1,
    pageSize: 20,
    predicate: p => p.IsActive,
    projection: p => new ProductSummaryDto 
    { 
        Id = p.Id, 
        Name = p.Name, 
        Price = p.Price 
    }
);
```

### **3. Operações Transacionais**
```csharp
using var transaction = await repository.BeginTransactionAsync();
try
{
    await repository.AddAsync(newProduct);
    await repository.UpdateAsync(existingProduct);
    await repository.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

### **4. Bulk Operations**
```csharp
// Adicionar múltiplas entidades
await repository.AddRangeAsync(products);

// Deletar em lote
var deletedCount = await repository.DeleteManyAsync(p => p.ExpiryDate < DateTime.UtcNow);

// Atualizar em lote
await repository.UpdateRangeAsync(productsToUpdate);
```

## Otimizações de Performance

### **1. Tracking Seletivo**
```csharp
// Para consultas read-only, desabilitar tracking
var products = await repository.GetManyAsync(
    predicate: p => p.IsActive,
    trackChanges: false  // Melhora performance significativamente
);
```

### **2. Projeções Eficientes**
```csharp
// Usar projeções para reduzir dados transferidos
var productNames = await repository.GetManyAsync(
    predicate: p => p.IsActive,
    projection: p => p.Name,
    trackChanges: false
);
```

### **3. Paginação Otimizada**
```csharp
// Paginação com contagem otimizada
var pagedResult = await repository.GetPagedAsync(
    pageNumber: 1,
    pageSize: 50,
    predicate: p => p.IsActive,
    orderBy: p => p.CreatedAt,
    optimizeCount: true  // Skip count se não necessário
);
```

## Integração com Multi-Tenancy

### **Filtros Automáticos por Tenant**
```csharp
public class TenantAwareRepository<TEntity> : BaseRepository<TEntity> 
    where TEntity : class, ITenantEntity
{
    private readonly ICurrentTenantService _tenantService;

    protected override IQueryable<TEntity> BuildBaseQuery(bool includeDeleted = false, bool trackChanges = true)
    {
        var query = base.BuildBaseQuery(includeDeleted, trackChanges);
        
        if (!string.IsNullOrEmpty(_tenantService.CurrentTenantId))
        {
            query = query.Where(e => e.TenantId == _tenantService.CurrentTenantId);
        }
        
        return query;
    }
}
```

## Auditoria e Logging

### **Interceptação de Operações**
```csharp
public override async Task<TEntity> AddAsync(TEntity entity, CancellationToken cancellationToken = default)
{
    _logger.LogInformation("Adding entity {EntityType} with ID {EntityId}", typeof(TEntity).Name, GetEntityId(entity));
    
    var result = await base.AddAsync(entity, cancellationToken);
    
    _logger.LogInformation("Successfully added entity {EntityType} with ID {EntityId}", typeof(TEntity).Name, GetEntityId(result));
    
    return result;
}
```

### **Métricas de Performance**
```csharp
public async Task<IEnumerable<TEntity>> GetManyAsync(...)
{
    using var activity = _activitySource.StartActivity($"Repository.GetMany.{typeof(TEntity).Name}");
    var stopwatch = Stopwatch.StartNew();
    
    try
    {
        var result = await GetManyInternalAsync(...);
        
        activity?.SetTag("result.count", result.Count());
        activity?.SetTag("execution.time_ms", stopwatch.ElapsedMilliseconds);
        
        return result;
    }
    catch (Exception ex)
    {
        activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
        throw;
    }
}
```

## Tratamento de Erros

### **Exceções Específicas**
```csharp
public async Task<TEntity> UpdateAsync(TEntity entity, CancellationToken cancellationToken = default)
{
    try
    {
        _context.Entry(entity).State = EntityState.Modified;
        await _context.SaveChangesAsync(cancellationToken);
        return entity;
    }
    catch (DbUpdateConcurrencyException ex)
    {
        throw new ConcurrencyConflictException("A entidade foi modificada por outro usuário", ex);
    }
    catch (DbUpdateException ex) when (ex.InnerException is SqlException sqlEx && sqlEx.Number == 2)
    {
        throw new DatabaseTimeoutException("Timeout ao atualizar entidade", ex);
    }
}
```

### **Retry Policies**
```csharp
[Retry(3, DelayBetweenRetries = 1000)]
public async Task<TEntity> AddAsync(TEntity entity, CancellationToken cancellationToken = default)
{
    // Implementação com retry automático para falhas transitórias
}
```

## Testing e Mocking

### **Setup para Testes**
```csharp
public class ProductRepositoryTests
{
    private readonly Mock<DbContext> _mockContext;
    private readonly Mock<DbSet<Product>> _mockDbSet;
    private readonly IRepository<Product> _repository;

    public ProductRepositoryTests()
    {
        _mockContext = new Mock<DbContext>();
        _mockDbSet = new Mock<DbSet<Product>>();
        _mockContext.Setup(c => c.Set<Product>()).Returns(_mockDbSet.Object);
        _repository = new BaseRepository<Product>(_mockContext.Object, Mock.Of<ILogger>());
    }

    [Test]
    public async Task GetByIdAsync_ShouldReturnEntity_WhenExists()
    {
        // Arrange
        var productId = 1;
        var expectedProduct = new Product { Id = productId, Name = "Test Product" };
        _mockDbSet.Setup(d => d.FindAsync(productId)).ReturnsAsync(expectedProduct);

        // Act
        var result = await _repository.GetByIdAsync(productId);

        // Assert
        Assert.That(result, Is.EqualTo(expectedProduct));
    }
}
```

## Melhorias Implementadas na Refatoração

### **Funcionalidades Adicionadas**
1. **Controle de Estado**: GetEntityState, SetEntityState para tracking avançado
2. **Paginação Rica**: IPagedResult com metadados completos
3. **Soft Delete**: Suporte nativo com restore
4. **Projeções**: GetPagedProjectionAsync para DTOs
5. **Bulk Operations**: AddRangeAsync, UpdateRangeAsync, DeleteManyAsync
6. **Transações**: ITransactionManager integrado

### **Padrões Aplicados**
1. **Generic Repository**: Type-safe e reutilizável
2. **Unit of Work**: Controle transacional integrado
3. **Specification**: Expression trees para consultas complexas
4. **Command Query Separation**: Métodos claramente separados

### **Melhorias de Performance**
1. **Tracking Seletivo**: trackChanges opcional
2. **Lazy Loading**: includes sob demanda
3. **Paginação Otimizada**: count opcional
4. **Projection Support**: redução de dados transferidos

## Roadmap de Evolução

### **Próximas Funcionalidades**
1. **Caching**: Integração com Redis/MemoryCache
2. **Read Replicas**: Suporte a databases de leitura
3. **Batch Processing**: Operações em lote otimizadas
4. **GraphQL**: Suporte a consultas GraphQL

### **Integrações Futuras**
1. **Event Sourcing**: Suporte a eventos de domínio
2. **CQRS**: Separação de comandos e consultas
3. **Elasticsearch**: Busca textual avançada
4. **Message Queues**: Operações assíncronas

## Conclusão

A interface `IRepository<TEntity>` fornece uma base sólida e extensível para acesso a dados, implementando padrões modernos e best practices. A refatoração introduziu funcionalidades avançadas, melhorou a performance e aumentou significativamente a flexibilidade e testabilidade do sistema.
